28. Inserción de datos con los seeders de Laravel


Notas
=====


En la sección anterior cargamos datos de prueba utilizando un administrador de base de datos, sin embargo esto trae como consecuencia que cada vez que ejecutemos migrate:refresh o migrate:fresh perdamos dichos datos. En esta lección veremos una mejor forma de cargar datos de prueba utilizando los Seeders de Laravel.



Generar un seeder
-----------------

Para generar un seeder utilizamos el comando de Artisan make:seeder seguido del nombre del seeder:
php artisan make:seeder ProfessionSeeder

Al ejecutar este comando se generará un archivo ProfessionSeeder.php dentro del directorio database/seeds.


Código del seeder
-----------------
Dentro del método run() del archivo ProfessionSeeder.php escribimos el código de nuestro seeder:

---
	class ProfessionSeeder extends Seeder
	{
	    public function run()
	    {
	        DB::table('professions')->insert([
	            'title' => 'Desarrollador back-end',
	        ]);
	    }
	}
--


Para insertar datos, utilizaremos el constructor de consultas SQL de Laravel. Que incluye una interfaz fluida para construir y ejecutar consultas a la base de datos. Para ello llamaremos al método "table" del Facade "DB" pasando como argumento el nombre de la tabla con la que queremos interactuar. El método "insert" acepta un array asociativo que representará las columnas y valores que queremos guardar en la tabla.


>> Para utilizar el facade DB:: debemos importar \Illuminate\Support\Facades\DB al principio del archivo:


---
	<?php
	// (namespace opcional aqui)
	use Illuminate\Support\Facades\DB;
---




Registrar seeder
----------------

Los seeders son registrados en la clase "DatabaseSeeder" dentro de "database/seeds/DatabaseSeeder.php". Dentro del método "run" llamamos al método "call" pasando como argumento el nombre de la clase de nuestro seeder:

---
	class DatabaseSeeder extends Seeder
	{
	    public function run()
	    {
	        $this->call(ProfessionSeeder::class);
	    }
	}
---




En este caso "ProfessionSeeder::class" devolverá el nombre de la clase. En lugar de utilizar "::class" también podemos pasar el nombre de la clase como una cadena de texto 'ProfessionalSeeder'.



Eliminar registros
-------------------

Es posible que antes de ejecutar un seeder necesitemos eliminar el contenido existente. Para realizar esto podemos utilizar el método "truncate", que se encarga de vaciar la tabla:

---
	class ProfessionSeeder extends Seeder
	{
	    public function run()
	    {
	        DB::table('professions')->truncate();
	        // ..
	    }
	}
---


Ejecutar un seeder
------------------

Para ejecutar los seeders utilizamos el comando db:seed desde la terminal:
	> php artisan db:seed


En caso de que tengas múltiples seeders, puedes pasar la opción "--class" que te permite ejecutar solamente el seeder pasado como argumento:
	> php artisan db:seed --class=ProfessionSeeder


También puedes ejecutar el comando "migrate:fresh" o "migrate:refresh" junto con los seeders pasando la opción "--seed":
	> php artisan migrate:fresh --seed



Desactivar revisión de claves foráneas
--------------------------------------

Si una tabla tiene una referencia de clave foránea, necesitarás desactivar la revisión de claves foráneas utilizando un sentencia antes de vaciar dicha tabla (por ejemplo usando el método "truncate").

Esto podemos lograrlo con la sentencia SQL "SET FOREIGN_KEY_CHECKS=[0|1]". En Laravel podemos ejecutar dicha sentencia usando el método "DB::statement" de esta manera:

---
	class ProfessionSeeder extends Seeder
	{
	    public function run()
	    {
	        DB::statement('SET FOREIGN_KEY_CHECKS = 0;'); // Desactivamos la revisión de claves foráneas
	        DB::table('professions')->truncate();
	        DB::statement('SET FOREIGN_KEY_CHECKS = 1;'); // Reactivamos la revisión de claves foráneas
	        // ..
	    }
	}
---

Utilizando la misma sentencia pero con el valor 1 reactivamos la revisión de claves foráneas luego de ejecutar nuestro seeder.



En caso de que quieras vaciar varias tablas a la vez, puedes utilizar el siguiente código dentro de la clase "DatabaseSeeder":

---
	class DatabaseSeeder extends Seeder
	{
	    public function run()
	    {
	        $this->truncateTables([
	            'nombre_de_la_tabla_aqui',
	            'nombre_de_otra_tabla',
	        ]);
	  
	        // Ejecutar los seeders:
	        $this->call(ProfessionSeeder::class);
	    }
	    public function truncateTables(array $tables)
	    {
	        DB::statement('SET FOREIGN_KEY_CHECKS = 0;');
	        foreach ($tables as $table) {
	            DB::table($table)->truncate();
	        }
	        DB::statement('SET FOREIGN_KEY_CHECKS = 1;');
	    }
	}
---


Ahora podrás llamar al método "truncateTables" pasando un arreglo con los nombres de las tablas que quieras vaciar.


Contraseñas dentro de un seeder
--------------------------------

En caso de que quieras insertar usuarios de esta manera, recuerda encriptar las contraseñas utilizando el helper "bcrypt":

---

	DB::table('users')->insert([
	    // ..
	    'password' => bcrypt('laravel')
	]);

---




Practicas
=========

Anteriormente creamos la base de la Base de datos, en esta sección vamos a comenzar a agregar los datos y para ello vamos a utilizar un nuevo componente llamado "seeders".

En el ejemplo anterior para agregar algunas profesiones utilizamos phpmyadmin y bien desde la consola de MySQL o bien un administrador de base de datos a elegir. Lo importante es que se esta agrgegando la iformación o datos manualmente. Cada vez que se ejecute comandos como migrate:refresh o migrate:fresh perdamos dichos datos. Asi como estamos ejecutando un comando para crear las tablas, lo ideal es que se ejecute un comando para cargar los datos de prueba y no los perdamos cada vez que  necesitemos restaurar la base de datos, ademas estos datos estan como codigos dentro de nuestro proyecto cualquier persona que clone el repositori, va no solamente a reproducir la base de datos si no tambien cargar algunos datos de prueba.

Para esto vamos a utilizar los "seeders" de Laravel y vamos a ejecutar el primero de ellos con el comando:
	> php artisan make:seeder <nombre_seeder>

Por ejemplo si queremos un "seeder"	para agregar profesiones, vamos a llamarla
	> php artisan make:seeder ProfessionSeeder   

En el editor podemos ver que tenemos una nueva clase, y de nuevo esta dando solo un caparazon donde uno puede comenzar a escribir el codigo.Esn este caso vamos a escribir el codigo dentro del metodo "run".


--- ProfessionSeeder.php

<?php

use Illuminate\Database\Seeder;

class ProfessionSeeder extends Seeder
{
    /**
     * Run the database seeds.
     *
     * @return void
     */
    public function run()
    {
        //
    }
}


---


Asiq ue vamos a utuilizar nuevamente un de los Facase de Laravel, em este caso al Facade DB, se puede utilizar el nombre de espacio completo, directamente desde aca desde el metodo "run": 


---ProfessionSeeder

	public function run()
    {
		Illuminate\Support\Facades\DB::;        
    }
---


O se puede importar el nombre de espacio al principio del archivo. De la siguiente manera:

Importando el nameespace:


	use Illuminate\Support\Facades\DB;        

---ProfessionSeeder

<?php

use Illuminate\Database\Seeder;
use Illuminate\Support\Facades\DB;        

class ProfessionSeeder extends Seeder
{
    /**
     * Run the database seeds.
     *
     * @return void
     */
    public function run()
    {
        DB::
    }
}

---

Y al hacer esto podemos referirnos a esta clase simplemente como "DB::", luego se va a allamar al metdo "table" y entonces se va a colocar el nombre de la tabla con la que queremos interactuar, en este caso es la tabla "professions".


---ProfessionSeeder

<?php

use Illuminate\Database\Seeder;
use Illuminate\Support\Facades\DB;        

class ProfessionSeeder extends Seeder
{
    /**
     * Run the database seeds.
     *
     * @return void
     */
    public function run()
    {
        DB::table('professions')->insert([
        	'name' => 'Back-end developer'
        ]);
    }
}

---

Este metodo va a aceptar un array asociativo que  va a respresentar las columnas o atributos o valores que se quieren guardar en esta tabla de professiones, em este caso se va a etener una sola columna llamada "nombre"  y como valores se va a tener la profesion por ejemplo "Back-end developer" o "Desarrollador "Back-end. 

Hecho el codigo anterior necesitamos registrar este seeder y para ello vamos a utilizar la clase Database Seeder que ya viene incluida en el proyecto base de Laravel "DatabaseSeeder"

Como podemos ver en este ejemplo vamos a llamar al metodo "call" y luego como primer argumento vamos a pasar el nombre de nuestra clase en este caso "ProfessionSeeder"


--- DatabaseSeeder.php

<?php

use Illuminate\Database\Seeder;

class DatabaseSeeder extends Seeder
{
    /**
     * Run the database seeds.
     *
     * @return void
     */
    public function run()
    {
        // $this->call(UsersTableSeeder::class);

        $this->call(ProfessionSeeder::class);
    }
}

---

Se esta utilizando esta sintaxis de class
	$this->call(ProfessionSeeder::class);


Y esto simplemente va a dar el  nombre de la clase.

Para verificar esto:

Se puede demostrar de la siguiente manera:

---DatabaseSeeder.php

public function run()
    {


    	dd(ProfessionSeeder::class);

        // $this->call(UsersTableSeeder::class);

        $this->call(ProfessionSeeder::class);
    }
---


Haciendo uso del metodo "dd" para que se pueda ver el resultado de utilizar esta sintaxis.
	dd(ProfessionSeeder::class);

Y ahora si regresamos a la consola podemos ejecutar:	
	> php artisan db:seed	
	"ProfessionSeeder"

En este caso solamente vamos a ver el nombre de la clase por que en este caso estamos utilizando  "dd". Podemos ver que el resultado es.

	"ProfessionSeeder"

Lo que quiere decir es que en lugar de utilizar esta sintaxis de class, tambien podria simplemente pasar el nombre de la clase y es equivalente. La diferencia de utilzar class es que si se comete un error, notese que la cadena de texto no va avisar que se tiene un error.

Pero si cometemos un error en este caso, entonces es posible que reciba una advertencia del editor. 	

	$this->call(ProfessionSeeder::class);

Por ejemplo aca sabemos que la clase no esta definida, teniendo claro este, podemos eliminar el metodo de ejemplo "dd". 


---DatabaseSeeder.php

public function run()
    {

        // $this->call(UsersTableSeeder::class);

        $this->call(ProfessionSeeder::class);
    }
---

De regreso a la consola ejecutamos:
	> php artisan db:seed

$ php artisan db:seed
"ProfessionSeeder"

Puede uriginar un error.
>>>

[Illuminate\Database\QueryException]
SQLSTATE[42S22]: Column not found: 1054 Unknown column 'name' in 'field list' (SQL: insert into 'professions' ('name') values (Desarrollador back-end)

[PDOException]
SQLSTATE [42S22]; Column not found: 1054 Unknown column 'name' in 'field list'


Y esto es por que al parecer el nombre de la columna "name" no fue encontrada en la tabla de profesiones, y con el codigo SQL que se intento ejecutar y en este caso fallo por que la columna 'name' no existe en esta tabla. Y esto es por que cuando uno creo la tabla de profesiones 
Mediante:
	La migracion: 2022_06_06_182413_create_professions_table.php


se le coloco, el nombre a laa columna 'title' en lugar de 'name'


---2022_06_06_182413_create_professions_table.php
  public function up()
    {
        Schema::create('professions', function (Blueprint $table) {
            $table->increments('id');
            $table->string('title', 100); //Este es el nombre de la columna registrado
            $table->timestamps();
        });
    }

---


Lo que quiere decir es que  en este caso necesitamos acomodar el "seeder" a menos que quieramos renombrar la columna, 

---	ProfessionSeeder.php

public function run()
    {
        DB::table('professions')->insert([
            'name' => 'Back-end developer'
        ]);
    }
	
---

Entonces simplemente acomodamos:

Consultamos antes:

mysql> select * from professions;
+----+---------------------+------------+------------+
| id | title               | created_at | updated_at |
+----+---------------------+------------+------------+
|  1 | Back-end developer  | NULL       | NULL       |
|  2 | Front-end developer | NULL       | NULL       |
+----+---------------------+------------+------------+



---
public function run()
    {
        DB::table('professions')->insert([
            'title' => 'Back-end developer'
        ]);
    }

---

De esta manera y de regtreso a la consola, entonces se va a a ejecutar nuevamente:
	> php artisan db:seed
	Seeding: ProfessionSeeder


Hecho esto podemos, comprobar el resultado de varias maneras:

- 	Una de estas opciones es regresar al administrador de base de datos y podemos ver que tenemos una nueva profession:


 select * from professions;
+----+---------------------+------------+------------+
| id | title               | created_at | updated_at |
+----+---------------------+------------+------------+
|  1 | Back-end developer  | NULL       | NULL       |
|  2 | Front-end developer | NULL       | NULL       |
|  3 | Back-end developer  | NULL       | NULL       |
+----+---------------------+------------+------------+
3 rows in set (0.00 sec)



Ahora lo que queremos es regresar al editor y agregar otra professión, por ejemplo "Front-end developer" o de "Desarrollador Front-end". Y otra professión para "diseñador Web" y asi sucesivamenmte.

---ProfessionSeeder.php

public function run()
    {
        DB::table('professions')->insert([
            'title' => 'Back-end developer'
        ]);


        DB::table('professions')->insert([
            'title' => 'Front-end developer'
        ]);

         DB::table('professions')->insert([
            'title' => 'Web Designer'
        ]);

    }

---


Si hacemos esto y regresamos a la consola y reejecutamos el comando 

	> php artisan db:seed
	Seeding: ProfessionSeeder


Podremos ver si regresamos al administrador de la base de datos, y podemos observar que tenemos varias profesiones repetidas:

mysql> select * from professions;
+----+---------------------+------------+------------+
| id | title               | created_at | updated_at |
+----+---------------------+------------+------------+
|  1 | Back-end developer  | NULL       | NULL       |
|  2 | Front-end developer | NULL       | NULL       |
|  3 | Back-end developer  | NULL       | NULL       |
|  4 | Back-end developer  | NULL       | NULL       |
|  5 | Front-end developer | NULL       | NULL       |
|  6 | Web Designer        | NULL       | NULL       |
+----+---------------------+------------+------------+



Por cierto quizas seria adecuado agregar una restricción de base de datos en la tabla de profesiones para eviar que tengamos duplicadas las profesioens con el mismo nobre o mismo titulo. Mediante el metodo "unique".

---2022_06_06_182413_create_professions_table.php
...
  public function up()
    {
        Schema::create('professions', function (Blueprint $table) {
            $table->increments('id');
            $table->string('title', 100)->unique();
            $table->timestamps();
        });
    }
...
---

Haciendo esto y regresamos a la consola para reejecutar:
	> php artisan db:seed
	Seeding: ProfessionSeeder


No se tienen errores, por que no se ha reejecutado las migraciones, entonces lo que se puede hacer en este caso es reejecuctar las migraciones:
	> php artisan migrate:fresh
	Dropped all tables successfully.
	Migration table created successfully.
	Migrating: 2014_10_12_100000_create_password_resets_table
	Migrated:  2014_10_12_100000_create_password_resets_table
	Migrating: 2014_10_12_100000_create_users_table
	Migrated:  2014_10_12_100000_create_users_table
	Migrating: 2022_06_06_182413_create_professions_table
	Migrated:  2022_06_06_182413_create_professions_table
	Migrating: 2022_06_09_210550_add_profession_id_to_users
	Migrated:  2022_06_09_210550_add_profession_id_to_users



Y ahora revisar la estructura de la base de datos para ver que la tabla de profesiones esta vacia.

mysql> select * from professions;
Empty set (0.00 sec)




En este punto, entonces podemos regresar a ejecutar el comando
	> php artisan db:seed
	Seeding: ProfessionSeeder


Para reejecutar los seeders

mysql> select * from professions;
+----+---------------------+------------+------------+
| id | title               | created_at | updated_at |
+----+---------------------+------------+------------+
|  1 | Back-end developer  | NULL       | NULL       |
|  2 | Front-end developer | NULL       | NULL       |
|  3 | Web Designer        | NULL       | NULL       |
+----+---------------------+------------+------------+


De esta manera entonces, crear los primeros registros en la tabla "professions" de forma muy sencilla. Ahora notemos que si volvemos a ejecutar 

	> php artisan db:seed

	Seeding: ProfessionSeeder

	In Connection.php line 664:

	  SQLSTATE[23000]: Integrity constraint violation: 1062 Duplicate entry 'Back-end developer' for key 'professions_title_unique' (SQL: insert into `profession
	  s` (`title`) values (Back-end developer))


	In Connection.php line 458:

	  SQLSTATE[23000]: Integrity constraint violation: 1062 Duplicate entry 'Back-end developer' for key 'professions_title_unique'


Ahora se produce un error por que se tiene una entrada duplicada, en esto caso en la tabla de "professions":
	>>>
	...SQL: insert into `professions` (`title`) values (Back-end developer)


Y esto es por que al reejecutar las migraciones entonces se creo la restriccion y no podemos tener 2 profesiones con el mismo nombre o el mismo titulo. Asi que si quiero eliminar todas las profesiones de la base de datos antes de crearlas nuevamente.

Para solucionar este problema puedo utilizar el metodo "truncate".


---ProfessionSeeder.php
    public function run()
    {
        
        DB::table('professions')->truncate(); 


        DB::table('professions')->insert([
            'title' => 'Back-end developer'
        ]);


        DB::table('professions')->insert([
            'title' => 'Front-end developer'
        ]);

        DB::table('professions')->insert([
            'title' => 'Web Designer'
        ]);
    }

---

En este caso notemos que se utiliza el "facade" DB luego "::" al metodo "table" y pasando el nombre de la tabla como primer argumento y luego entonces vamos a encadenar el metodo "truncate". Este metodo mi va a permitir vaciar la tabla.

asi que si regtresarmos, a la consola y volvemos a ejecuar


mysql> select * from professions;
+----+---------------------+------------+------------+
| id | title               | created_at | updated_at |
+----+---------------------+------------+------------+
|  1 | Back-end developer  | NULL       | NULL       |
|  2 | Front-end developer | NULL       | NULL       |
|  3 | Web Designer        | NULL       | NULL       |
+----+---------------------+------------+------------+


	> php artisan db:seed


	Seeding: ProfessionSeeder

	In Connection.php line 664:

	  SQLSTATE[42000]: Syntax error or access violation: 1701 Cannot truncate a table referenced in a foreign key constraint (`crudlaravel5_5`.`users`, CONSTRAIN
	  T `users_profession_id_foreign`) (SQL: truncate `professions`)


	In Connection.php line 458:

	  SQLSTATE[42000]: Syntax error or access violation: 1701 Cannot truncate a table referenced in a foreign key constraint (`crudlaravel5_5`.`users`, CONSTRAIN
	  T `users_profession_id_foreign`)



Ahora en este caso vamos a recibir un nuevo error, esto no quiere decir que mi codigo este mal escrito, si no que la table de profesiones tiene una restricción de clave foranea.Asociada en este caso en el campo "profession_id" en la tabla de usuarios. 

Asi que yo no puedo vaciar esta tabla de buenas a primeras a menos que desactive la revisión de llaves foraneas, pero de todas formas vamos  regresar al editor y se va a eliminar en:

Esta restricción de llave foranea

---2022_06_09_210550_add_profession_id_to_users.php

public function up()
    {
        Schema::table('users', function(Blueprint $table){

                $table->unsignedInteger('profession_id');
                

                //$table->foreign('profession_id')->references('id')->on('professions');

            });
    }


---


Hecho esto entonces en la consola y reejecutar:
	> php artisan migrate:fresh

	Dropped all tables successfully.
	Migration table created successfully.
	Migrating: 2014_10_12_100000_create_password_resets_table
	Migrated:  2014_10_12_100000_create_password_resets_table
	Migrating: 2014_10_12_100000_create_users_table
	Migrated:  2014_10_12_100000_create_users_table
	Migrating: 2022_06_06_182413_create_professions_table
	Migrated:  2022_06_06_182413_create_professions_table
	Migrating: 2022_06_09_210550_add_profession_id_to_users
	Migrated:  2022_06_09_210550_add_profession_id_to_users



Para eliminar todas las tablas y reejecutar las migraciones.	
>>>
	mysql> select * from professions;
	Empty set (0.00 sec)


En este caso nuevamente vamos a ejecutar el comando:
	> php artisan db:seed   
	Seeding: ProfessionSeeder


Si revisamos en la tabla de profesioens el contenido;


mysql> select * from professions;
Empty set (0.00 sec)


Explorando la tabla de profesiones, 


mysql> select * from professions;
+----+---------------------+------------+------------+
| id | title               | created_at | updated_at |
+----+---------------------+------------+------------+
|  1 | Back-end developer  | NULL       | NULL       |
|  2 | Front-end developer | NULL       | NULL       |
|  3 | Web Designer        | NULL       | NULL       |
+----+---------------------+------------+------------+


Podremos ver que tenemos nuestras tres profesioens aca y que ahora podemos reejecutar este comando cuantas veces se quiera.
	> php artisan bd:seed


Y siempre se va a tener las mismas tres profesiones;

mysql> select * from professions;
+----+---------------------+------------+------------+
| id | title               | created_at | updated_at |
+----+---------------------+------------+------------+
|  1 | Back-end developer  | NULL       | NULL       |
|  2 | Front-end developer | NULL       | NULL       |
|  3 | Web Designer        | NULL       | NULL       |
+----+---------------------+------------+------------+
3 rows in set (0.00 sec)


Que se estan agregando en "ProfessionSeeder", puesto que se esta vaciando la tabla antes de agregar las profesiones en:



---ProfessionSeeder.php
    public function run()
    {
        
        DB::table('professions')->truncate(); 


        DB::table('professions')->insert([
            'title' => 'Back-end developer'
        ]);


        DB::table('professions')->insert([
            'title' => 'Front-end developer'
        ]);

        DB::table('professions')->insert([
            'title' => 'Web Designer'
        ]);
    }

---

De regreso a la migración: "2022_06_09_210550_add_profession_id_to_users.php". si yo restauro la linea donde se esta definiendo la clave foranea.


---2022_06_09_210550_add_profession_id_to_users.php

public function up()
    {
        Schema::table('users', function(Blueprint $table){

                $table->unsignedInteger('profession_id');
                

                $table->foreign('profession_id')->references('id')->on('professions');

            });
    }


---


Por cierto se va a aproveechar para descomentar las lineas del metodo "down"



---2022_06_09_210550_add_profession_id_to_users.php
...	
	class AddProfessionIdToUsers extends Migration
	{
	    /**
	     * Run the migrations.
	     *
	     * @return void
	     */
	    public function up()
	    {
	        Schema::table('users', function(Blueprint $table){

	                $table->unsignedInteger('profession_id');
	                //$table->foreign('profession_id')->references('id')->on('professions');

	            });
	    }

	    /**
	     * Reverse the migrations.
	     *
	     * @return void
	     */
	    public function down()
	    {
	        Schema::table('users', function(Blueprint $table){

	            $table->dropForeign(['profession_id']);
	            $table->dropColumn('profession_id');

	        });
	    }
...
---

Regresamos a la consola y reejecutamos:
	> php artisan migrate:fresh
	Dropped all tables successfully.
	Migration table created successfully.
	Migrating: 2014_10_12_100000_create_password_resets_table
	Migrated:  2014_10_12_100000_create_password_resets_table
	Migrating: 2014_10_12_100000_create_users_table
	Migrated:  2014_10_12_100000_create_users_table
	Migrating: 2022_06_06_182413_create_professions_table
	Migrated:  2022_06_06_182413_create_professions_table
	Migrating: 2022_06_09_210550_add_profession_id_to_users
	Migrated:  2022_06_09_210550_add_profession_id_to_users



Para recrear las tablas

Y ahora ejecutamos:
	> php artisan db:seed

	Seeding: ProfessionSeeder

	In Connection.php line 664:

	  SQLSTATE[42000]: Syntax error or access violation: 1701 Cannot truncate a table referenced in a foreign key constraint (`crudlaravel5_5`.`users`, CONSTRAIN
	  T `users_profession_id_foreign`) (SQL: truncate `professions`)


	In Connection.php line 458:

	  SQLSTATE[42000]: Syntax error or access violation: 1701 Cannot truncate a table referenced in a foreign key constraint (`crudlaravel5_5`.`users`, CONSTRAIN
	  T `users_profession_id_foreign`)




Nuevamente vamos a obtenerel mismo error, en este caso podemos evitar este error si ejecutamos la siguiente sentencia:

Utilizando DB:statement y la sentencia va a ser: "SET FEREIGN_KEY_CHECKS = 0", con la cual vamos a desactivar la revisión de llaver foraneas en la base de datos, este es una sentencia SQL que se va a ejecutar en la base de datos antes de entonces mandar la orden para vaciar la tabla de "professions".
 

---ProfessionSeeder.php
    public function run()
    {

    	DB::statement('SET FOREIGN_KEY_CHECKS = 0');
        
        DB::table('professions')->truncate(); 

        DB::table('professions')->insert([
            'title' => 'Back-end developer'
        ]);

        DB::table('professions')->insert([
            'title' => 'Front-end developer'
        ]);

        DB::table('professions')->insert([
            'title' => 'Web Designer'
        ]);
    }

---


Con esto puedo regresar a la consola y entonces. Ahora podemos ejecutar el siguiente comando sin singun problema tantas veces como se requiera
	> php artisan db:seed
	Seeding: ProfessionSeeder


De regreso a la base de datos podemos explorar la tabla de profesiones y ver que siempre tengo tres profesiones:

mysql> select * from professions;
+----+---------------------+------------+------------+
| id | title               | created_at | updated_at |
+----+---------------------+------------+------------+
|  1 | Back-end developer  | NULL       | NULL       |
|  2 | Front-end developer | NULL       | NULL       |
|  3 | Web Designer        | NULL       | NULL       |
+----+---------------------+------------+------------+




quiza lo que interese reactivar el proceso de revisión de llaves foraneas, una vez que haya sido eliminada a tabla,  

---ProfessionSeeder.php
    public function run()
    {

    	DB::statement('SET FOREIGN_KEY_CHECKS = 0');
        
        DB::table('professions')->truncate(); 

        DB::statement('SET FOREIGN_KEY_CHECKS = 1');

        DB::table('professions')->insert([
            'title' => 'Back-end developer'
        ]);

        DB::table('professions')->insert([
            'title' => 'Front-end developer'
        ]);

        DB::table('professions')->insert([
            'title' => 'Web Designer'
        ]);
    }

---


Quizas interese eliminar varias tablas, en ese caso entonces podemos mover este codigo a nuestro seeder general que esta en: "DatabaseSeeder"


--- DatabaseSeeder.php

 public function run()
    {
        
    	DB::statement('SET FOREIGN_KEY_CHECKS = 0');
        
        DB::table('professions')->truncate();

        DB::statement('SET FOREIGN_KEY_CHECKS = 1');


        //dd(ProfessionSeeder::class);

        // $this->call(UsersTableSeeder::class);

        $this->call(ProfessionSeeder::class);
    }

---

Con esto podriamos ser capaces entonces de regresar a la consola y ejecutar, el siguiente comando tantas veces como queramos:

	> php artisan db:seed
	Seeding: ProfessionSeeder



mysql> select * from professions;
+----+---------------------+------------+------------+
| id | title               | created_at | updated_at |
+----+---------------------+------------+------------+
|  1 | Back-end developer  | NULL       | NULL       |
|  2 | Front-end developer | NULL       | NULL       |
|  3 | Web Designer        | NULL       | NULL       |
+----+---------------------+------------+------------+


Obteniendo siempre los mismos resultados sin ninguna complicación. Como a nosostros nos gusta trabajar de forma ordenada vamos a extraer el codigo

---
	DB::statement('SET FOREIGN_KEY_CHECKS = 0');
       
    DB::table('professions')->truncate();

    DB::statement('SET FOREIGN_KEY_CHECKS = 1');

---
	
A un metodo diferente con la ayuda del editor 

Extract method

Llamaresmoa a este "truncateTables", Pero queremos que este metodo reciba un array con los nombres de las tablas que queremos vaciar, en este caso entonces vamos a colocar un nuevo parametro llamado "$tables" que debe ser un array; en este caso no se le va a dar valor por defecto por que es obligatorio y entonces se coloca el codigo para vaciar las tablas dentro de un foreach de la siguiente forma:

---DatabaseSeeder.php
...
   public function run()
    {

    	$this->truncateTables([
	      'professions'
    	]);
        
        //dd(ProfessionSeeder::class);

        // $this->call(UsersTableSeeder::class);

        $this->call(ProfessionSeeder::class);
    }


     protected function truncateTables(array $tables)
    {
        DB::statement('SET FOREIGN_KEY_CHECKS = 0');
        
        DB::table('professions')->truncate();

        DB::statement('SET FOREIGN_KEY_CHECKS = 1');
    }

...
---


En la función truncateTable se utiliza el codigo siguiente para vaciar las tablas dentro de un "foreach" de la siguiente forma

---DatabaseSeeder.php
...
foreach ($$tables as $table) {
            
            DB::table('professions')->truncate();
        }
...
---

Se pasa el nombre de la tabla de forma dinamica, utilizzando la variable "$table":


---DatabaseSeeder.php
...
foreach ($$tables as $table) {
            
            DB::table($table)->truncate();
        }
...
---


Hecho esto regresamos a la consola para ejecutar:
	> php artisan db:seed


Incluso podemos ejecutar el anterior comando varias veces.

	> php artisan db:seed
	Seeding: ProfessionSeeder


	> php artisan db:seed
	Seeding: ProfessionSeeder


	A php artisan db:seed
	Seeding: ProfessionSeeder



Y si revisamos en la tabla correspondiente "professions" notaremos que se hizo la refactorización paso a paso 

mysql> select * from professions;
+----+---------------------+------------+------------+
| id | title               | created_at | updated_at |
+----+---------------------+------------+------------+
|  1 | Back-end developer  | NULL       | NULL       |
|  2 | Front-end developer | NULL       | NULL       |
|  3 | Web Designer        | NULL       | NULL       |
+----+---------------------+------------+------------+



Seeder de la tabla usuarios
---------------------------

Vamos ahora a agrgar un nuevo Seeder para la tabla de usuarios mediante el comando:
	> php artisan make:seeder UserSeeder


Se crea el archivo y lo editamos para comenzar a escribir el codigo:

---UserSeeder.php

 public function run()
 <?php

use Illuminate\Database\Seeder;
use Illuminate\Support\Facades\DB;

class UserSeeder extends Seeder
{
    /**
     * Run the database seeds.
     *
     * @return void
     */
    public function run()
    {
        //
    }
}

---


Dentro del metodo "run"  utilizamos "DB::table" con la tabla de "usuarios", por supuesto debemos importar la clase, lo hacemos con la ayuda del editor, aunque podemos hacerlo manualmente, podemos utilizar un ide que incluya la funcionalidad de importación, o instalar un plugin en el editor que se este utilizando.

Vamos a utilizar el metodo "insert" pero ahora para crear un usuario vamos a necesitar mas de un atributo por ejemplo el atributo "nombre", luego "email", "password", encriptada con la funcion helper bcrypt, y finalmente debemos pasar una "profesion", en este caso no vamos a pasar "desarrollador Backend" si no que queremos pasar el id asiciado a dicha profesion. 


¡Como podemos hacer esto?

Esto es algo que de hecho se vera en la sección siguiente, por ahora vamos a exluir este campo, quedando de la siguiente manera en la funcion "run:

---UserSeeder.php
...
  */
    public function run()
    {
       DB::table('users')->insert([
            'name' => 'Klvst3r',
            'email' => 'klvst3r@email.com',
            'password' => bcrypt('laravel'),

       ]);
    }

...
---


 Regresamos a la consola y vamos a ejecutar:
 	> php artisan db:seed
 	Seeding: ProfessionSeeder


Notemos que se muestra un solo mensaje de confirmación para el Seeder ProfessionSeeder, esto sucede por que si recordamos que denbemos registrar el Seeder dentro de "DatabaseSeeder.php".

Nuevamente llamamos al metodo "call" dentro de esta clase

---DatabaseSeeder.php
public function run()
    {

        $this->truncateTables([
          'professions'
        ]);



        //dd(ProfessionSeeder::class);

        // $this->call(UsersTableSeeder::class);

        $this->call(ProfessionSeeder::class);
        //Registro de UserSeeder
        $this->call(UserSeeder::class);

    }

---

Hecho esto ahora si podemos regresar a la terminal y reejecutar el comando:
	> php artisan db:Seeder
	Seeding: ProfessionSeeder
	Seeding: UserSeeder
>>>
	In Connection.php line 664:

	  SQLSTATE[HY000]: General error: 1364 Field 'profession_id' doesn't have a default value (SQL: insert into `users` (`name`, `email`, `password`) values (Klv
	  st3r, klvst3r@email.com, $2y$10$0AuV0tJhnb5tUgaiNup35OEQcEERMKGFmPZiUo4L9fsUj.F5feDda))


	In Connection.php line 458:

	  SQLSTATE[HY000]: General error: 1364 Field 'profession_id' doesn't have a default value



---


En este caso db:seed genera un error ya que profession_id no tiene un valor por defecto, puede deberse a que este campo no es "nullable", de cualquier forma se permite la corrección en la migración "2022_06_09_210550_add_profession_id_to_users.php"

Cambiando la linea :
	$table->unsignedInteger('profession_id');

---2022_06_09_210550_add_profession_id_to_users.php
public function up()
    {
        Schema::table('users', function(Blueprint $table){

                $table->unsignedInteger('profession_id')->nullable();
                
                $table->foreign('profession_id')->references('id')->on('professions');

            });
    }

---

Regresamos a la consola para reejecutar las migraciones nuevamente:

	> php artisan migrate:fresh
	Dropped all tables successfully.
	Migration table created successfully.
	Migrating: 2014_10_12_100000_create_password_resets_table
	Migrated:  2014_10_12_100000_create_password_resets_table
	Migrating: 2014_10_12_100000_create_users_table
	Migrated:  2014_10_12_100000_create_users_table
	Migrating: 2022_06_06_182413_create_professions_table
	Migrated:  2022_06_06_182413_create_professions_table
	Migrating: 2022_06_09_210550_add_profession_id_to_users
	Migrated:  2022_06_09_210550_add_profession_id_to_users



Reejecutamos las migraciones, y ahora se pueden reejejcutar los seeders.

	> php artisan db:seed
	Seeding: ProfessionSeeder
	Seeding: UserSeeder

Podemos revisar la tabla de "usuarios".

mysql> select * from users;
+----+---------+-------------------+--------------------------------------------------------------+----------------+------------+------------+---------------+
| id | name    | email             | password                                                     | remember_token | created_at | updated_at | profession_id |
+----+---------+-------------------+--------------------------------------------------------------+----------------+------------+------------+---------------+
|  1 | Klvst3r | klvst3r@email.com | $2y$10$JZJjL3oBSHp7CfLne.Iln.54IKsmygI7/x.5Dxlbam.nSNMfk3oJy | NULL           | NULL       | NULL       |          NULL |
+----+---------+-------------------+--------------------------------------------------------------+----------------+------------+------------+---------------+


Podemos revisar que se creo un usuario exitosamente.

Ahora si regresamos a la consola y reejecutamos los seeders nuevamente:

	> php artisan db:seed
>>>	
	Seeding: ProfessionSeeder
	Seeding: UserSeeder

	In Connection.php line 664:

	  SQLSTATE[23000]: Integrity constraint violation: 1062 Duplicate entry 'klvst3r@email.com' for key 'users_email_unique' (SQL: insert into `users` (`name`, `
	  email`, `password`) values (Klvst3r, klvst3r@email.com, $2y$10$jSDAghKonFKrX/Eg0Mjnw.5vXjPnwkpmU7ev1pXPNRJxdzk4N2A6e))


	In Connection.php line 458:

	  SQLSTATE[23000]: Integrity constraint violation: 1062 Duplicate entry 'klvst3r@email.com' for key 'users_email_unique'

---


Obtendremos otro error por que en este caso estamos intentando crear el mismo resgistro del usuario dos veces, cuando en la tabla de "usuarios", donde se indica que el campo "email" es unico.

---2014_10_12_100000_create_users_table.php
 public function up()
    {
        Schema::create('users', function (Blueprint $table) {
            $table->increments('id'); //Integer unsigned - Autoincrement

            $table->string('name'); //varchar
            $table->string('email')->unique(); //varchar - Unique
            $table->string('password'); 
            $table->rememberToken();
            $table->timestamps();
        });
    }
---


Es decir no podemos registrar a dos usuarios con el mismo email con la base de datos; todas estas protecciones son a nivel de base de datos, mas adelante se vera como se puede hacer esta protección a nivel de aplicación, es decir a nivel de interfaz de usuario, formualrios, etc.


Para prevenir el error mostrado durante la ejecuación de los seeders, simplemante debemos regresar al seeder "DatabaseSeeder.php" e indicar que queremos vaciar tambien la tala de usuarios. Si es que queremos volvar de inicio toda la inforamción tambien de esta tabla.

--- DatabaseSeeder.php

public function run()
    {

        $this->truncateTables([
          'users',
          'professions'
        ]);



        //dd(ProfessionSeeder::class);

        // $this->call(UsersTableSeeder::class);

        $this->call(ProfessionSeeder::class);
        //Registro de UserSeeder
        $this->call(UserSeeder::class);

    }

---


Ahora se tiene este pequeño metodo que es muy facil de hacerlo.
---DatabaseSeeder.php

   $this->truncateTables([
          'users',
          'professions'
        ]);

---


Regresamos a la consola y rejecutamos:
	> php artisan db:seed
	Seeding: ProfessionSeeder
	Seeding: UserSeeder

Y ahora podemos reejecutar cuantas veces sea neceario

	> php artisan db:seed
	Seeding: ProfessionSeeder
	Seeding: UserSeeder

	> php artisan db:seed
	Seeding: ProfessionSeeder
	Seeding: UserSeeder

	> php artisan db:seed
	Seeding: ProfessionSeeder
	Seeding: UserSeeder


Por cierto si queremos ejecutar el comando "migrate:fresh", seguido del comando "db:seed" al comando migrate fresh
	> php artisan migrate:fresh --seed
	Dropped all tables successfully.
	Migration table created successfully.
	Migrating: 2014_10_12_100000_create_password_resets_table
	Migrated:  2014_10_12_100000_create_password_resets_table
	Migrating: 2014_10_12_100000_create_users_table
	Migrated:  2014_10_12_100000_create_users_table
	Migrating: 2022_06_06_182413_create_professions_table
	Migrated:  2022_06_06_182413_create_professions_table
	Migrating: 2022_06_09_210550_add_profession_id_to_users
	Migrated:  2022_06_09_210550_add_profession_id_to_users
	Seeding: ProfessionSeeder
	Seeding: UserSeeder



Podemos fijarnos que se eliminan todas las tablas con el sistema de migraciones y finalmente se ejecutan los seeders.

De esta manera es mucho mejor y mas rápido.


Posteriormente se vera la introducción a los modelos de Laravel, crear usuarios que tengan profesiones asociadas.















Ejericios
=========


En el caso de extremo, podríamos poner el atributo onDelete('cascade') junto con engine='InnoDB' y las relaciones de clave externa se eliminarían automáticamente.


Hola, cómo sería la forma de ingresar una cantidad de 700 registros a un seeder de una forma no tan manual?

Se puede cargar un CSV en una DB de la siguiente manera


--- database > seeds > CIEsSeeder.php

/* Run de database seed.
*
* @return function run()
{
	try {

		$doc = explode("\r\n", Storage::disk('public')->get('/docs/cie-10.csv'));
		DB::table('c_i_e_s')->insert([
			'id' => 1,
			'name' => CIE-10,
		]);

		foreach($doc as $key => $ln) {
			if ($ln != ";") {
				$diseases = explode (";", $ln);
				if (count($diseases) == 2){
					DB::table('diseases')->insert([
						'code' => $deseases[0],
						'description' => $diseases[1],
						'cie_id' => 1,
					]);
				}
			}
		}

	}catch(Exception $err){

	}
}


} //funtion main

---

* $users = factory(User::class, 700)->create();
solo que tendrias que crear un fabrica para generar datos de prueba

* Me di cuenta que al ejecutar un Seeder en particular, por ejemplo:
$ php artisan db:seed --class=ProfessionSeeder

No pasa por DatabaseSeeder.php
En ese caso, creo que tendria que colocar la logica de truncate dentro de ProfessionSeeder.php en el metodo run() antes de los inserts.

* Me pasaba que cuando ejecutaba el comando:
php artisan db:seed

Resultado:
Seeding: ProfessionSeeder

Class ProfessionSeeder does not exist

Y la clase estaba bien creada y el call a la clase en el archivo: DatabaseSeeder.php estaba llamado correctamente:
$this->call(ProfessionSeeder::class);

Probe haciendo un:
composer dump-autoload

Y luego funcionó correctamente.


*  Tengo un inconveniente con el siguiente error "SQLSTATE[42704]: Undefined object: 7 ERROR: parámetro de configuración no reconocido: «forei
gn_key_checks» (SQL: SET FOREIGN_KEY_CHECKS = 0;) " eso al ejecutar "php artisan db:seed"

* pero cambiando DB::statement('TRUNCATE TABLE professions CASCADE;'); se soluciono

* Cuando utilizas esta opción, cuando se va a borrar una profesión, ¿Primero se borran todos los usuarios que tienen esa profesión? ¿Manteniendo así la integridad de la base de datos?




Referencias:
============


Cómo mejorar la apariencia y funcionalidad de PhpStorm

Vamos a enseñar cómo configurar PhpStorm para trabajar en tus proyectos con Laravel y Vue.js.


¿Qué IDE usas?

Comencemos con el IDE: en casi todos los cursos de PHP y Laravel utilizo PhpStorm

PhpStorm es un IDE muy completo y ya trae todo lo que necesitas para trabajar con PHP, sin embargo necesitarás realizar varios pasos extra para que luzca como la imagen debajo y además soporte la sintaxis del sistema de plantillas de Laravel (Blade) y los componentes de Vue.js.

Alternativas a PhpStorm

PhpStorm no es gratis, Jet Brains lo ofrece a cambio de una membresía mensual o anual que te permitirá obtener el software con sus respectivas actualizaciones. Así que cuando yo no tenía la posibilidad de comprarlo usaba NetBeans IDE para PHP o Aptana 3 que son excelentes IDEs y son gratuitos.

PhpStorm también ofrece una licencia para estudiantes universitarios, si quieres usar el IDE para fines educativos (no comerciales).

También puedes descargar y utilizar el editor Sublime Text el cuál no es un IDE, lo que quiere decir que no ofrece el mismo auto completado de PhpStorm, Netbeans o Aptana, aunque puedes configurarlo para emular las características de dichos IDEs guiándote con el excelente post de Matt Stauffer que explica cómo configurar Sublime para desarrolladores de PHP.

Sea cual sea la opción que elijas por favor elige una opción legal, descargar programas piratas no sólo daña nuestra industria, sino que puede dañar tu computador y hacerte perder horas y horas que puedes aprovechar estudiando, trabajando o configurando tu editor. Usar software legal te da actualizaciones automáticas e incluso soporte si tienes un problema. Te recomiendo además leer cuestión de actitud.
Plugins para PhpStorm

Una vez instalado el IDE, te recomiendo que instales y actives los siguientes plugins:

    Blade Support
    Material Theme UI
    vue-for-idea
    SASS Support

Pasos para instalar los plugins:

    Ve al menú principal de PhpStorm
    Luego: preferences
    Dentro busca la opción plugins
    Verás la lista de plugins que ya vienen por defecto
    Usa el buscador para filtrar la opción que buscas
    Si no la consigues entonces presiona «Search in repositories» (ver imagen debajo)
    Asegúrate que el plugin que quieras esté activado
    Desactiva los plugins que no necesitas.
    Reinicia el IDE.



Una vez que instales y habilites todos los plugins recuerda reiniciar el IDE para que los cambios tengan efecto.
Tema para PhpStorm

Como puedes ver en la lista de plugins instalamos Material Theme UI,  este es el tema de colores para el IDE como tal. Sin embargo yo no uso Material Theme para el editor (es decir para el código) porque me parece que los colores son muy brillantes.

Un tema que me gusta mucho y he usado bastante en los videos es Spacegray, si quieres usarlo has lo siguiente:

    Sigue las instrucciones de instalación desde el repositorio del tema Spacegray, para tu sistema operativo.
    Luego de instalar el tema, reinicia el IDE.
    Ve al menú principal de PhpStorm
    Luego: preferences
    Ahora ve a la opción Colors & Fonts dentro de Editor y selecciona el tema.
    Luego selecciona «Save As…» y cámbiale el nombre a algo como «Spacegray custom», esto creará una copia del tema
    Reinicia el IDE.

Normalizar color de fondo de la barra lateral y del editor de texto

Luego de instalar Material Theme UI y el tema Spacegray notarás que el color de fondo de la barra lateral y del editor de texto no son los mismos, si esto te quita el sueño como a mí, puedes arreglarlo de dos formas:

    Instala el plugin Color Ide que hará que la barra lateral de PhpStorm sea del mismo color del fondo del editor de texto (en este caso el color del tema Spacegray).
    Ve a General en la opción de Fonts & Color en preferencias y cambia el color de fondo (background) en las opciones «Editor / Gutter background» y «Text / Default Text» al color hexadecimal #263238 que es el color de Material Theme UI. Esta es la opción que yo elegí, 




Si recibiera 1 dólar cada vez que alguien me pregunta qué editor, fuente o tema uso, no necesitaría tener planes pagos en Styde para mantener el proyecto y pagar la renta. Pero como eso no va a pasar, permíteme contestarte con este post, donde además te enseñaré cómo configurar PhpStorm para trabajar en tus proyectos con Laravel y Vue.js.

¿Qué IDE usas?

Comencemos con el IDE: en casi todos los cursos de PHP y Laravel utilizo PhpStorm, excepto en el curso de Programación orientada a objetos donde utilicé Sublime Text.

PhpStorm es un IDE muy completo y ya trae todo lo que necesitas para trabajar con PHP, sin embargo necesitarás realizar varios pasos extra para que luzca como la imagen debajo y además soporte la sintaxis del sistema de plantillas de Laravel (Blade) y los componentes de Vue.js.

Captura del proyecto «Crea una aplicación con Laravel 5.3»
Alternativas a PhpStorm

PhpStorm no es gratis, Jet Brains lo ofrece a cambio de una membresía mensual o anual que te permitirá obtener el software con sus respectivas actualizaciones. Así que cuando yo no tenía la posibilidad de comprarlo usaba NetBeans IDE para PHP o Aptana 3 que son excelentes IDEs y son gratuitos.

PhpStorm también ofrece una licencia para estudiantes universitarios, si quieres usar el IDE para fines educativos (no comerciales).

También puedes descargar y utilizar el editor Sublime Text el cuál no es un IDE, lo que quiere decir que no ofrece el mismo auto completado de PhpStorm, Netbeans o Aptana, aunque puedes configurarlo para emular las características de dichos IDEs guiándote con el excelente post de Matt Stauffer que explica cómo configurar Sublime para desarrolladores de PHP.

Sea cual sea la opción que elijas por favor elige una opción legal, descargar programas piratas no sólo daña nuestra industria, sino que puede dañar tu computador y hacerte perder horas y horas que puedes aprovechar estudiando, trabajando o configurando tu editor. Usar software legal te da actualizaciones automáticas e incluso soporte si tienes un problema. Te recomiendo además leer cuestión de actitud.
Plugins para PhpStorm

Una vez instalado el IDE, te recomiendo que instales y actives los siguientes plugins:

    Blade Support
    Material Theme UI
    vue-for-idea
    SASS Support

Pasos para instalar los plugins:

    Ve al menú principal de PhpStorm
    Luego: preferences
    Dentro busca la opción plugins
    Verás la lista de plugins que ya vienen por defecto
    Usa el buscador para filtrar la opción que buscas
    Si no la consigues entonces presiona «Search in repositories» (ver imagen debajo)
    Asegúrate que el plugin que quieras esté activado
    Desactiva los plugins que no necesitas.
    Reinicia el IDE.

Una vez que instales y habilites todos los plugins recuerda reiniciar el IDE para que los cambios tengan efecto.
Tema para PhpStorm

Como puedes ver en la lista de plugins instalamos Material Theme UI,  este es el tema de colores para el IDE como tal. Sin embargo yo no uso Material Theme para el editor (es decir para el código) porque me parece que los colores son muy brillantes.

Un tema que me gusta mucho y he usado bastante en los videos es Spacegray, si quieres usarlo has lo siguiente:

    Sigue las instrucciones de instalación desde el repositorio del tema Spacegray, para tu sistema operativo.
    Luego de instalar el tema, reinicia el IDE.
    Ve al menú principal de PhpStorm
    Luego: preferences
    Ahora ve a la opción Colors & Fonts dentro de Editor y selecciona el tema.
    Luego selecciona «Save As…» y cámbiale el nombre a algo como «Spacegray custom», esto creará una copia del tema
    Reinicia el IDE.

Normalizar color de fondo de la barra lateral y del editor de texto

Luego de instalar Material Theme UI y el tema Spacegray notarás que el color de fondo de la barra lateral y del editor de texto no son los mismos, si esto te quita el sueño como a mí, puedes arreglarlo de dos formas:

    Instala el plugin Color Ide que hará que la barra lateral de PhpStorm sea del mismo color del fondo del editor de texto (en este caso el color del tema Spacegray).
    Ve a General en la opción de Fonts & Color en preferencias y cambia el color de fondo (background) en las opciones «Editor / Gutter background» y «Text / Default Text» al color hexadecimal #263238 que es el color de Material Theme UI. Esta es la opción que yo elegí, como puedes ver en la imagen debajo:

Si eliges la opción 2 asegúrate de no instalar o deshabitar Color Ide. Además no olvides reiniciar el IDE en caso de que haga falta.
Fuente para PhpStorm

Para programar necesitas una fuente que sea monospaced, esto quiere decir que cada carácter va a ocupar el mismo espacio, sin importar si es una «i» o una «m» y por supuesto hay varias opciones que puedes elegir.

Laravel News publicó un artículo sobre las 5 fuentes principales para programar. De ellas yo utilizo Menlo (creo que ya viene por defecto en OSX) y hace poco instalé «Fira Code» con la opción de ligaduras de fuente que hace que símbolos en PHP como «->» o «!=» luzcan como un solo carácter.

Pasos para instalar la fuente:

    Busca la fuente que quieras en Google e instálala para tu sistema operativo
    Reinicia el IDE
    Ve al menú principal de PhpStorm
    Luego: preferences
    Ahora ve a la opción Fonts dentro de Fonts & Colors y selecciona la fuente que quieras.
    Si estás usando una fuente como Fira Code, asegúrate de marcar la opción «Enable font ligatures» (ver imagen debajo)

El tamaño de fuente e interlineado depende del tamaño de tu monitor y tus preferencias personales, yo creo que un interlineado de al menos 1.2 con un máximo de 1.6 es ideal. La fuente puede ser de tamaño 14 a 20 pero de nuevo depende de tus preferencias. Yo uso una fuente grande para que el código se pueda ver en los videos aunque no los veas en pantalla completa.
Habilitar el formato en los archivos .vue

Aunque instales el plugin vue-for-idea, es posible que los archivos .vue (que sirven para programar componentes de Vue.js) no tengan formato. En ese caso:

    Ve de nuevo a preferencias
    Busca la opción «File Types» dentro de Editor
    Selecciona «HTML» en «Recognized File Types»
    Revisa la lista «Registered Patterns» que aparecerá debajo, debe tener *.htm, *.html y otras.
    Presiona en el icono + debajo de la lista de Registered Patterns y agrega *.vue.
    Presiona «Apply»

Desaparecer los menus que trae PhpStorm

Los programadores nos distraemos muy fácilmente y PhpStorm por defecto no ayuda mucho en este tema. 

Para ocultarlas ve a la opción «View» del menú y desmarca las opciones «Toolbar», «Toolbar buttons», etc.

También puedes eliminar las pestañas desde preferencias, busca «Tabs» en el buscador y en «Placement» selecciona «None»:

Ahora busca la opción Web browser y deshabilita «Show browser popup in the editor» y también busca y deshabilita los «breadcrumbs» buscando «Breadcrumbs» y luego desmarcando la opción «Show breadcrumbs».
Conclusión

Con todos estos cambios obtendrás un IDE no solo bastante completo sino visualmente atractivo y ya estarás casi listo para desarrollar aplicaciones increíbles con Laravel.