27. Crear y asociar tablas usando las migraciones de Laravel (con claves foráneas)


Notas
=====

En esta sección del Capitulo 3 de la guia del Framework de Laravel desde cero veremos más a fondo el sistema de migraciones de Laravel. En esta oportunidad, veremos cómo crear nuevas tablas y cómo crear asociaciones entre una tabla y otra utilizando claves foráneas. También veremos un poco más sobre las convenciones que podemos utilizar al momento de generar nuevas migraciones y sobre otros métodos para definir campos.

Convenciones al ejecutar migraciones
------------------------------------

Al generar una migración con el comando php artisan make:migration si utilizamos el siguiente formato para el nombre: create_NOMBRE DE LA TABLA_table, Laravel automáticamente generará el código requerido para crear dicha tabla:
php artisan make:migration create_professions_table

Producirá el siguiente código boilerplate:
----
	public function up()
	{
	    Schema::create('professions', function (Blueprint $table) {
	        $table->increments('id');
	        $table->timestamps();
	    });
	}

---

Ahora sólo tenemos que definir las columnas.

También podemos pasar la opción --create en caso de que no queramos usar la convención:
	php artisan make:migration new_professions_table --create=professions

A la opción create pasamos como valor el nombre de la tabla.



Restricción de clave foránea
----------------------------
Podemos añadir una restricción de clave foranea a nuestro campo utilizando el método foreign():
---
	Schema::create('users', function (Blueprint $table) {
	    // ...
	    $table->unsignedInteger('profession_id'); 
	    $table->foreign('profession_id')->references('id')->on('professions');
	    // ...
	});
---

En este caso indicamos que el campo profession_id va a hacer referencia al campo id en la tabla professions.

Aquí es importante que el tipo del campo profession_id coincida con el campo id en la tabla professions. Es decir el campo profession_id debe ser definido como un entero positivo, para ello usamos el método:

$table->unsignedInteger('nombre_del_campo_aqui'); o $table->integer('nombre_del_campo')->unsigned();


Claves primarias
----------------
Cuando diseñamos una base de datos, suele ser importante tener un campo (o combinación de campos) que pueda identificar de manera única a cada fila. Así como se tiene un número de pasaporte que es único, cada usuario o profesión va a tener un identificador (id) único. En esta base de datos usaremos identificadores de tipo auto-incremento, es decir la primera fila obtendrá el identificador 1, la segunda 2, y así sucesivamente. Estos identificadores serán generados por el motor de la base de datos.



Claves Foráneas
---------------
Para asociar una tabla con otra, vamos a utilizar una clave foránea. Por ejemplo en la tabla de usuarios, utilizaremos el campo profession_id, cuyo valor va a ser un identificador (id) válido de uno de los registros de la tabla de profesiones. De esta manera asociaremos un registro (fila) la tabla usuarios con un registro (fila) de la tabla de profesiones. En este tipo de relaciones solemos decir que un Usuario pertenece a una Profesión. También podemos decir que una Profesión tiene muchos Usuarios. Puesto que pueden existir 100 usuarios que sean desarrolladores back-end o 50 usuarios que sean desarrolladores front-end, cada profesión va a tener asignada muchos usuarios. Por otro lado cada usuario solo puede tener asignada una profesión (aunque en la vida real hay personas que tienen más de una profesión, en nuestro sistema esto no es relevante).



Practica
========


Cuando se comienza con el desarrollo de un proyecto con Laravel, no se suele empezar creando toda las tablas, es decir todas las migraciones, ni diseñando la base de datos primero que nada. Sino que se puede comentar con las pruebas automatizadas vistas en secciones atras. Y son estas pruebas las que suelen indicar que tablas, y columnas se deben crear. Y asi se va poco a poco estructurando la BD, sin embargo se ha pretendido exoplicar con esta guia desde cero de forma que vayamos aprendiendo componente por compomenente. 

En esta sección vamos a aprender más sobre el sistema de migraciones de Laravel. 

Suponiendo que ya tenemos nuestro formulario de registro y que ya se tienen usuarios registrandose en nuesto proyecto, y nos hemos dado cuenta que varios usuarios que se han registrado tienen la misma profesión, sin embargo la han escrito de forma diferente; por ejemplo, el primer usuario escribio "Backend developer", el segundo "Back-end developer" y un tercero "Back-end programmer". Entonces tenemos tres usuarios que tienen la misma profesión, pero estan escritas de forma diferente y esto va a dificultar que nosotros puedamos hacer busquedas o mostrar resultados dependiendo de la profesion que tengan. Asi deberiamos solucionarlo de una mejor manera y seguramente hemos padecido esta situacion en donde para registrar la profesión debemos seleccionarla de una lista y no escribirla en un campo de texto. Esto es lo que se pretende aca. 

Primero a nivel de base de datos y más adelante en secciones futuras en un formulario de busqueda.

Para ello, vamoa a regresar a la consola y vamos a crear una nueva migración:
	> php artisan make:migration create_professions_table


Puesto que se va a querer crear una tabla de profesiones, y es ahi donde vamos a colocar las profesiones que consideramos validas para que el usuario seleccione una al momento de registra su información en el formulario o de editar su perfil de usuario. 	


Regresando al editor veremos que ahora tenemos un nuevo archivo de migración, y como utilizamos una foram de convención, Laravel automaticamente nos va a dar el codivo boilerplate para crear la tabla de profesiones:

---2022_06_06_174018_create_professions_table.php
...
	public function up()
    {
        Schema::create('professions', function (Blueprint $table) {
            $table->increments('id');
            $table->timestamps();
        });
    }
...
---


Podemos demostrar como funciona esto si se inspecciona una de las clases del Framework que se llama "MigrateMakeCommand"

En la ruta:
	C:\AppServ\www\dev\CRUDLaravel5.5\vendor\laravel\framework\src\Illuminate\Database\Console\Migrations
---
...
	class MigrateMakeCommand extends BaseCommand
{
    /**
     * The console command signature.
     *
     * @var string
     */
    protected $signature = 'make:migration {name : The name of the migration.}
        {--create= : The table to be created.}
        {--table= : The table to migrate.}
        {--path= : The location where the migration file should be created.}';

    /**
     * The console command description.
     *
     * @var string
     */
    protected $description = 'Create a new migration file';
...
---	


Esta es la clase donde va a estar el codigo para generar una nueva migracion, donde se puede ver la declaración del comando, pero lo que se pretender ver es lo siguiente en el mismo archivo:
---
...line 86
if (! $table) {
            if (preg_match('/^create_(\w+)_table$/', $name, $matches)) {
                $table = $matches[1];

                $create = true;
            }
        }
...
---

Que en el metodo "handle" que se va a encargar de crear esta migración Laravel en elgun momento va a revisar si el patrón que se esta utilizando para el nombre de la migración incluye el prefijo "create" y el subfijo "table". De ser asi entonces Laravel automaticamente va a generar el código boilerplate para que entonces se pueda crear una nueva tabla, esto no va a suceder si uno por ejemplo ejecuta el comando:
	> php artisan make:migration new_professions_table

Si escribimos de esta manera el comando y regresamos a la migración notaremos que no tenemos el codigo boilerplate para crear una nueva tabla

---
class NewProfessionsTable extends Migration
{
    /**
     * Run the migrations.
     *
     * @return void
     */
    public function up()
    {
        //
    }

    /**
     * Reverse the migrations.
     *
     * @return void
     */
    public function down()
    {
        //
    }

---


Por supuesto uno puede escribirlo rapidamente, pero si utilizamos la convención entonces ahorraremos algo de tiempo, tambien podremos especificar esto manualmente si no quememos utilizar la convencion, ejecutando:

Sintaxis
	> php artisan make migration <nombre_archivo> --create=<nombre_tabla>

Comando:
	> php artisan make:migration new_professions_table --create=professions


Regresando al editor y abriendo la migración creada podremos observar que se tiene creada el codigo boilerplate con la utilización del parametro "--create" volvemos a tener el codigo boilerplate para comenzar a crear nuestra tabla en el metodo up() y en el metodo down(), debemos fijarnos que tenemos el codigo para crear y eliminar la tabla respectimanete. Esto fue agregado por Laravel automaticamente al momento de crear la nueva migración.

Vamos  a trabajar con la primera migración que se creo, entonces queremos que la tabla tenga:

---2022_06_06_174018_create_professions_table.php
...
	public function up()
    {
        Schema::create('professions', function (Blueprint $table) {
            $table->increments('id');

			$table->increments('title', 100);	

            $table->timestamps();
        });
    }
...
---

Si regresamos a la consola y ejecutamos el comando:
	> php artisan migrate


puedo entonces ir a PHPmyAdmin y ver que tengo una nueva tabla llamada profesions, sin embargo yo en la tabla de usuarios aun tengo 

+------------+------------------+------+-----+---------+----------------+
| Field      | Type             | Null | Key | Default | Extra          |
+------------+------------------+------+-----+---------+----------------+
| id         | int(10) unsigned | NO   | PRI | NULL    | auto_increment |
| title      | varchar(100)     | NO   |     | NULL    |                |
| created_at | timestamp        | YES  |     | NULL    |                |
| updated_at | timestamp        | YES  |     | NULL    |                |
+------------+------------------+------+-----+---------+----------------+


Más sin embargo en la tabla de usuarios aun se tiene la columna:


+----------------+------------------+------+-----+---------+----------------+
| Field          | Type             | Null | Key | Default | Extra          |
+----------------+------------------+------+-----+---------+----------------+
| id             | int(10) unsigned | NO   | PRI | NULL    | auto_increment |
| name           | varchar(255)     | NO   |     | NULL    |                |
| email          | varchar(255)     | NO   | UNI | NULL    |                |
| password       | varchar(255)     | NO   |     | NULL    |                |
| profession     | varchar(50)      | YES  |     | NULL    |                | <- Es una cadena de Texto
| remember_token | varchar(100)     | YES  |     | NULL    |                |
| created_at     | timestamp        | YES  |     | NULL    |                |
| updated_at     | timestamp        | YES  |     | NULL    |                |
+----------------+------------------+------+-----+---------+----------------+


Pero deseamos que esta columna "profession" que es una cadena de texto, pero queremos que ahora esta columna permita asociar a cada usuario registrado en el sistema con un profesion de la tabla professions, y puesto que cada profesion va a tener un "id" o un identificador, Vamos a desmostrarlo de la siguiente manera:

Agregamos dos profesiones

	- Back-end developer
	- Front-end developer

Mas adelante veremos como podemos insertar esta información directamente con Laravel, pero ahora lo haremos de manera manual, po lo que. Via phpmyadmin

-*-*
	INSERT INTO `professions` (`id`, `title`, `created_at`, `updated_at`) VALUES (NULL, 'Back-end developer', NULL, NULL), (NULL, 'Front-end developer', NULL, NULL);
-*-*


+----+---------------------+------------+------------+
| id | title               | created_at | updated_at |
+----+---------------------+------------+------------+
|  1 | Back-end developer  | NULL       | NULL       |
|  2 | Front-end developer | NULL       | NULL       |
+----+---------------------+------------+------------+

Ya tenemos dos profesiones en el sistema, cada una de ellas tiene un identificador, y puesto que la intencion es asociar a cada uno de los usuaarios en el sistema, con una de las profesiones ya existentes en la tabla professions. vamos a utilizar no una cadena de texto, sino un entero sin signo, para que cada registro tenga relacion con el indentificador de la trabla "professions". 

Asi por ejemplo la profession "Back-end developer" tiene el id 1, entones en la columna 

+----------------+------------------+------+-----+---------+----------------+
| Field          | Type             | Null | Key | Default | Extra          |
+----------------+------------------+------+-----+---------+----------------+
| id             | int(10) unsigned | NO   | PRI | NULL    | auto_increment |
| name           | varchar(255)     | NO   |     | NULL    |                |
| email          | varchar(255)     | NO   | UNI | NULL    |                |
| password       | varchar(255)     | NO   |     | NULL    |                |
| profession     | varchar(50)      | YES  |     | NULL    |                | <- Een ves de almacenar la cadena de texto "Back-end developer" vamos a almacenar el valor 1
| remember_token | varchar(100)     | YES  |     | NULL    |                |
| created_at     | timestamp        | YES  |     | NULL    |                |
| updated_at     | timestamp        | YES  |     | NULL    |                |
+----------------+------------------+------+-----+---------+----------------+


Y cuando en BD se utiliza un acolumna para hacer referencia con otra tabla se le da el nombre de clave foranea o llave foranea, puesto que esta columna que tienemos en la tabla professions, es la llave primaria de la tabla es decir el identificador unico para cada registro de esta tabla, para cuando queramos hacer referencia a una llave o clave ajena de esta tabla, entonces se le da el nombre de llave o clave foranea, y para identificar que una columna va a ser una clave foranea solemao darle el subfijo de "_id" o "id". Asi que vamos a crar una nueva migracion con el comando:
	> php artisan make:migration add_profession_id_to_users

Es decir vamos a agregar la columna "profession_id"	 a la tabla "users".

Ya en la migración:


---2022_06_07_154449_add_profession_id_to_users
...
	 public function up()
    {
        Schema::table('users', function(Blueprint $table){
            $table->dropColumn('profession');

            $table->unsignedInteger('profession_id');
        });
    }
...
---

Se comienza a escribir esta migración nuevamente, utilizando el Phasas "Schema" con el nombre de la tabla va a ser 'users' nuevamente y nuevamente vamos a utilizar una funcion anonima con el objeto de la clase "Blueprint" para eliminar la columna profession y agregar otra columna que llamara "profesion_id" y esta columna va a ser un entero sin signo, es decir un entero positivo.

Puedo hacerlo de esta manera o utilizar el metodo integer() y luego encadenar el metodo unsigned(), somo se muestra a continuación:

---2022_06_07_154449_add_profession_id_to_users
...
	 public function up()
    {
        Schema::table('users', function(Blueprint $table){
            $table->dropColumn('profession');

            $table->integer('profession_id')->unsigned();
        });
    }
...
---

Ahora en el metodo down(), queremos hacer la operación contraria, 
 
 ---2022_06_07_154449_add_profession_id_to_users
 ...

	  public function down()
	    {
	        Schema::table('users', function(){
	            $table->dropColumn('profession_id');

	            $table->string('profession', 50)->nullable()->after('password');
	        });
	    }
 ...
 ---



Aqui quiero eliminar la columna "profession_id" y crear nuevamente la columna "profession" despues de la columna password de tipo string con longitud de 50 caracteres.

Probamos regresando a la consola:
	> php artisan migrate 

Y podemos ver si regreso ahora a a ver la estructura de la tabla y podemos observar que ahora tenemos la columna profession_id


+----------------+------------------+------+-----+---------+----------------+
| Field          | Type             | Null | Key | Default | Extra          |
+----------------+------------------+------+-----+---------+----------------+
| id             | int(10) unsigned | NO   | PRI | NULL    | auto_increment |
| name           | varchar(255)     | NO   |     | NULL    |                |
| email          | varchar(255)     | NO   | UNI | NULL    |                |
| password       | varchar(255)     | NO   |     | NULL    |                |
| remember_token | varchar(100)     | YES  |     | NULL    |                |
| created_at     | timestamp        | YES  |     | NULL    |                |
| updated_at     | timestamp        | YES  |     | NULL    |                |
| profession_id  | int(10) unsigned | NO   |     | NULL    |                |
+----------------+------------------+------+-----+---------+----------------+


Ahora podemos ver que tenemos la columna "profession_id" y ya no tenemos la columna "profession". Sin embargo nuestras migraciones estan un poco desordenadas, por que si regresamos al editor tenemos una migración para agragar una columna, pero luego tenemos una migración para eliminar la misma columna, 


---
<?php

use Illuminate\Support\Facades\Schema;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Database\Migrations\Migration;

class AddProfessionIdToUsers extends Migration
{
    /**
     * Run the migrations.
     *
     * @return void
     */
    public function up()
    {
        Schema::table('users', function(Blueprint $table){
            $table->dropColumn('profession');

            $table->unsignedInteger('profession_id');
        });
    }

    /**
     * Reverse the migrations.
     *
     * @return void
     */
    public function down()
    {
        Schema::table('users', function(){
            $table->dropColumn('profession_id');

            $table->string('profession', 50)->nullable()->after('password');
        });
    }
}


---


Esto puede hacerse un poco dificil de leel, casos como este que apenas estamos comenzando el desarrollo de nuestro proyecto donde no tenemos una base de datos en producción y no tenemos datos reales, etc.

En vez de estar agregando un monton de migraciones sin sentido, nosotros simplemente podemos modificar migraciones ya existentes y recrear la base de datos, por ejemplo:


---
	$table->unsignedInteger('profession_id');
---
Yo puedo directamente puedo agregar la columna "profession_id" que va a ser una columna que simplemente va a ser un entero sin signo, es decir un entero positivo y puedo agregar esta columna directamente a la tabla de usuarios en la migracion de ["...create_users_table.php"]. De esta manera ya no voy a necesitar las dos migraciones (...add_profession_to_users.php y ...add_profession_id_to_users.php)

---...create_users_table.php

public function up()
    {
        Schema::create('users', function (Blueprint $table) {
            $table->increments('id'); //Integer unsigned - Autoincrement
            $table->string('name'); //varchar
            $table->string('email')->unique(); //varchar - Unique
            $table->string('password'); 
            $table->unsignedInteger('profession_id');
            $table->rememberToken();
            $table->timestamps();
        });
    }
---

De esta manera puedo yo ya no necesitar a las dos migraciones que agregan una columna y que agregan una clave de "profession_id" para una clave foranea:

eliminamos:

- 2022_06_04_230004_add_profession_to_users.php
- 2022_06_07_154449_add_profession_id_to_users.php


Regresar a la consola y reejecutar el comando:
	> php artisan migrate:refresh


Salida:
>>
	$ php artisan migrate:refresh
	Migration not found: 2022_06_07_154449_add_profession_id_to_users 	<- Error por no encontrar el archivo
	Rolling back: 2022_06_06_182413_create_professions_table
	Rolled back:  2022_06_06_182413_create_professions_table
	Migration not found: 2022_06_04_230004_add_profession_to_users 		<- Error por no encontrar el archivo
	Rolling back: 2014_10_12_100000_create_password_resets_table
	Rolled back:  2014_10_12_100000_create_password_resets_table
	Rolling back: 2014_10_12_000000_create_users_table
	Rolled back:  2014_10_12_000000_create_users_table
	Migrating: 2014_10_12_000000_create_users_table
	Migrated:  2014_10_12_000000_create_users_table
	Migrating: 2014_10_12_100000_create_password_resets_table
	Migrated:  2014_10_12_100000_create_password_resets_table
	Migrating: 2022_06_06_182413_create_professions_table
	Migrated:  2022_06_06_182413_create_professions_table


Podemos ver que hay un par de errores, sin embargo Laravel vera la manera de regresar todas las migraciones y reejecutarlas nuevamante, y asi ahora regresamos a la Base de datos en la tabla 'users' y veremos que ahora tenemos la columna "profession_id" en la tabla de usuarios.

+----------------+------------------+------+-----+---------+----------------+
| Field          | Type             | Null | Key | Default | Extra          |
+----------------+------------------+------+-----+---------+----------------+
| id             | int(10) unsigned | NO   | PRI | NULL    | auto_increment |
| name           | varchar(255)     | NO   |     | NULL    |                |
| email          | varchar(255)     | NO   | UNI | NULL    |                |
| password       | varchar(255)     | NO   |     | NULL    |                |
| profession_id  | int(10) unsigned | NO   |     | NULL    |                |
| remember_token | varchar(100)     | YES  |     | NULL    |                |
| created_at     | timestamp        | YES  |     | NULL    |                |
| updated_at     | timestamp        | YES  |     | NULL    |                |
+----------------+------------------+------+-----+---------+----------------+

Por otro lado se tiene la tabla "professions" en la tabla "professions" para guardar todas las profesiones del sistema, sin embargo veremos que si agregamos nuevamente dos profesiones;

---MySQL
	INSERT INTO `professions` (`id`, `title`, `created_at`, `updated_at`) VALUES (NULL, 'Back-end developer', NULL, NULL), (NULL, 'Front-end developer', NULL, NULL);
---

Inspeccionando la tabla "professions".

+----+---------------------+------------+------------+
| id | title               | created_at | updated_at |
+----+---------------------+------------+------------+
|  1 | Back-end developer  | NULL       | NULL       |
|  2 | Front-end developer | NULL       | NULL       |
+----+---------------------+------------+------------+

Y ahora nos camos a la tabla de 'users' y agregamos un usuario, si bien es cierto que desde un administrador grafico como phpmyadmin agregar por ejemplo la siguiente informacion:

name 'Klvst3r'
email 'klvst3r@klvst3r.io'
password 'clave'
profession 1 o 2 <- Para hacer referencia a la profesion 1 o 2 de la tabla professions

---
	INSERT INTO `users` (`id`, `name`, `email`, `password`, `profession_id`, `remember_token`, `created_at`, `updated_at`) VALUES (NULL, 'Klvst3r', 'admin@klvst3r.io', 'clave', '1', NULL, NULL, NULL);
---

No tengo nada que me impida por ejemplo, que yo regrese aca y edite un usuario registrando un numero con el valor por ejemplo '50' en el campo profession_id, a pesar de que la profession 50 no existe en la base de datos. Yo puedo evitar que esto suceda y mantener la integridad de la base de datos si agrego una restricción de clave o llave foranea. Esto puedo hacerlo directamente con Laravel.

Para ello vamos a regresar al editor y modificar la migracion "...create_users_table.php" para crear la tabla de usuarios y voy agregar entonces una restriccion de clave foranea-

Para ello entonces voy a definir la columna como antes pero 

---...create_users_table

 public function up()
    {
        Schema::create('users', function (Blueprint $table) {
            $table->increments('id'); //Integer unsigned - Autoincrement
            $table->string('name'); //varchar
            $table->string('email')->unique(); //varchar - Unique
            $table->string('password'); 
            $table->rememberToken();
            $table->timestamps();
        });
    }
---

  
Se agrega una restricción de clave foranea, para ello se define la columna como antes pero se va a llmar al metodo foreing para decir que la columna "profession_id"  va a hacer referencia al campo "id" en la tabla "professions".


---...create_users_table

 public function up()
    {
        Schema::create('users', function (Blueprint $table) {
            $table->increments('id'); //Integer unsigned - Autoincrement

            $table->unsignedInteger('profession_id');
            $table->foreing('profession_id')->references('id')->on('professions');

            $table->string('name'); //varchar
            $table->string('email')->unique(); //varchar - Unique
            $table->string('password'); 
            $table->rememberToken();
            $table->timestamps();
        });
    }
---


si yo hago esto puedo regresar a la consola y reejecutar

Sin embargo ahora si se va a obtener un error.


>>>

Rolling back: 2022_06_06_182413_create_professions_table
Rolled back:  2022_06_06_182413_create_professions_table
Rolling back: 2014_10_12_100000_create_password_resets_table
Rolled back:  2014_10_12_100000_create_password_resets_table
Rolling back: 2014_10_12_000000_create_users_table
Rolled back:  2014_10_12_000000_create_users_table
Migration not found: 2022_06_07_154449_add_profession_id_to_users 	<-Migración ya no incluida
Migration not found: 2022_06_04_230004_add_profession_to_users
Migrating: 2014_10_12_000000_create_users_table
Migrated:  2014_10_12_000000_create_users_table
Migrating: 2014_10_12_100000_create_password_resets_table
Migrated:  2014_10_12_100000_create_password_resets_table
Migrating: 2022_06_06_182413_create_professions_table
Migrated:  2022_06_06_182413_create_professions_table


En este caso


	> php artisan migrate:refresh


>>>
$ php artisan migrate:refresh
Rolling back: 2022_06_06_182413_create_professions_table
Rolled back:  2022_06_06_182413_create_professions_table
Rolling back: 2014_10_12_100000_create_password_resets_table
Rolled back:  2014_10_12_100000_create_password_resets_table
Rolling back: 2014_10_12_000000_create_users_table
Rolled back:  2014_10_12_000000_create_users_table
Migration not found: 2022_06_07_154449_add_profession_id_to_users
Migration not found: 2022_06_04_230004_add_profession_to_users

In Macroable.php line 96:

  Method foreing does not exist.

Esto inidica que no puede modificar la tabla de usuarios para agregar esta restricción y esto ocurre por que esta tabla "professions" no existe es decir no ha sido creada, puesto que Laravel va a ejecutar la migración para crear la tabla de usuarios y luego es que va a ejecutar la migracion para crear la tabla de professions. Asi que si queremos evitar este eoror. tendo dos alternativas. 

Primer Metodo
-------------
La primera seria modificar la marca de tiempo en el archivo de migración.

	De 2014_10_12_000000_create_users_table.php

Para que quede despues de la migración de "professions"

	A 2022_07_06_180000_create_users_table.php

donde la tabla de "profesions tiene la siguiente marca de tiempo:
	
	2022_06_06_182413_create_professions_table.php

Si yo hago esto y regreso a la consola y reejecuto el comando:
	> php artisan migrate:refresh

Lamentablemente se sigue obteniendo un error.

Esto sucede a veces cuando ocurre un error y ejecutamos una migración y las migraciones quedan en un estado inconsistente que Laravel no sabe como recuperarse.

somo es nuestro caso, hay dos formas muy sencillas en que se puede arreglar el problema.

La primera es 

1. regresar con phpmyadmin en la base de datos y eliminar todas las tablas por completo. Habilitando la revisión de llaves foraneas.

	Hecho esto podremos regresar a la consola y simplemente ejecutar 

		> php artisan migrate 

	Laravel va a crear las migraciones desde cero, como si nada hubiese pasado.


2. Otra solución que esta disponible a partir de Laravel 5.5 es utilizar el comando 
	> php artisan migrate:fresh

	Este comando va a eliminar todas las tablas de la base de datos y va a comanzar desde cero, creando la tabla de migraciones y luego ejecutando cada migración una por una.

	Este comando es muy util, pero de nuevo es muy destructivo, en este caso va a eliminar todas las tablas que hayan sido creadas con el sistema de migraciones o no. Por su puesto si tenemos temor de que Laravel vaya a eliminar todas las tablas del proyecto, esto va a suceder unicamente si se ejecutan estos comandos. 

	De hecho si estamos en el entorno de producción y para ello, vamos a modificar el archivo de entorno para colocar que vamos a estar en un entorno de producción y no en un entorno local.

	Editanto
		.env	

		Cambiando:

			 APP_ENV=local

			 por

			 APP_ENV=production

	 y ejecutamos:

	 	> php artisan migrate:fresh

	 Laravel va a preguntar si realemnte deseamos ejecutar este comando,

	 En este caso concelamos.

	 Asi que Laravel nos va a proteger un poco de que cometamos uno de estos errores si estamos directamente trabajando en el servidor de producción si estamos modificando la bas de datops del servidor de produccón. Por que antes de todo deberiamos crear un respaldo, independientemente de si estamos trabajando con un freamework o no. siempre es imporatne respaldar antes de haceer cualquier cambio en la base de datos de producion del proyecto especifico.


Segundo Metodo
-------------
	 Otra solución por supuesto si no queremos cambiar la fecha de la migración para la tabla de usuarios, seria crear la tabla de "usuarios" sin la llave foranea "profession_id" luego crear en otra migración la tabla de "professions" y finalmente agregar una migración extra para entonces agregar esta columna y clave foranea. 



	 Tomando considerachón que a este punto solo existen tres migraciones a ejecutar:

	 - create_password_resets_table
	 - create_users_table
	 -create_professions_table




Regresando 	 la migración de "...create_users_table.php" a:

	De 2014_10_12_000000_create_users_table.php

Posterior a ellos seria crear la tabla de usuarios sin la llave "profession_id"

Cambiando de esto:

---2014_10_12_000000_create_users_table.php

	public function up()
    {
        Schema::create('users', function (Blueprint $table) {
            $table->increments('id'); //Integer unsigned - Autoincrement

            $table->unsignedInteger('profession_id');
            $table->foreing('profession_id')->references('id')->on('professions');

            $table->string('name'); //varchar
            $table->string('email')->unique(); //varchar - Unique
            $table->string('password'); 
            $table->rememberToken();
            $table->timestamps();
        });
    }
---


A esto:


---2014_10_12_000000_create_users_table.php

	public function up()
    {
        Schema::create('users', function (Blueprint $table) {
            $table->increments('id'); //Integer unsigned - Autoincrement

            
            $table->string('name'); //varchar
            $table->string('email')->unique(); //varchar - Unique
            $table->string('password'); 
            $table->rememberToken();
            $table->timestamps();
        });
    }
---


Luego crear en otra migración la tabla de "professions"



---2022_06_06_182413_create_professions_table.php

	class CreateProfessionsTable extends Migration
{
    /**
     * Run the migrations.
     *
     * @return void
     */
    public function up()
    {
        Schema::create('professions', function (Blueprint $table) {
            $table->increments('id');
            $table->string('title', 100);
            $table->timestamps();
        });
    }
---



Y finalmente agregar una migración extra, para entonces agrgar esta columna y clave foranea:

	>  

>>>
	$ php artisan make:migration add_profession_id_to_users
	Created Migration: 2022_06_09_181531_add_profession_id_to_users

Como ya hemos aprendido.

--- 2022_06_09_181531_add_profession_id_to_users.php
...
	class AddProfessionIdToUsers extends Migration
	{
	    /**
	     * Run the migrations.
	     *
	     * @return void
	     */
	    public function up()
	    {
	        Schema:table('users', function(Blueprint $table){

	        	$table->unsignedInteger('profession_id');
            	$table->foreing('profession_id')->references('id')->on('professions');

	        });
	    }

	    /**
	     * Reverse the migrations.
	     *
	     * @return void
	     */
	    public function down()
	    {
	        //
	    }
	}

---


en este caso sin embargo debemos tener cuidado de agregar entonces en el metodo down() para eliminar esta columna. y tambien la clave foranea

--- 2022_06_09_181531_add_profession_id_to_users.php

...
public function down()
    {
        Schema:table('users', function(Blueprint $table){

            $table->dropForeign(['profession_id']);
            $table->dropColumn('profession_id');

        });
    }

---


eliminando priomero la clave foranea con el metodo dropForeing(), y luego eliminar la columna con el metodo dropcolumn(). 


Hecho esto entonces podemos regresar a la consola y ejecutar:
	> php migrate:fresh

y tambien ahora puede ejecutarse el comando:
	> php artisan migrate:refresh


Para comprobar que se ha creado la tabla de "migrations" corretamente. 

Como nota adicional.

Si no necesitamos la funcionalidad de rollback ni de refresh solamente vamos a utilizar el metodo fresh en este caso. Ya no hace falta que se defina el codigo en el metodo down()

---ad_profession_id_to_user

 public function down()
    {
        /*Schema::table('users', function(Blueprint $table){

            $table->dropForeign(['profession_id']);
            $table->dropColumn('profession_id');

        });*/
    }

---


Coemntamos las lineas del metodo down()

Regresamos a la consola y ejecutamos:
	> php artisan migrate:refresh

-vanios a obtener un error, nuevamante un error de restrccion de llave foranea puesto que estamos tratando de eliminar la tabla professions cuando tenemos una llave foranea asociada a esta tabla. Puesto que aca cuando se regreso esta migración para gregar la columna profession_id a users no se elimino la clave foranea en este caso la base de datos no esta dejando eliminar la tabla de profesiones, pero si nosotros ejecutamos el comando 

	> php artisan migrate:fresh

Puesto que Laravel simplemente va a eliminar todas las tablas, en este caso no importa si yo he definio o no el codigo dentro del metodo down()	 , asi que podemos excluir este codigo.

Al escribir la logica en el metodo down es opcional si solamente vamos a utilizar el comando
	php artisan migrate:fresh

sin embargo es obligatorio si vamos a utilizar la funcionalidad de refresh y de rollback.

Por ultimo vamos a inspeccionar la base de datos una vez mas

+--------------------------+
| Tables_in_crudlaravel5_5 |
+--------------------------+
| migrations               |
| password_resets          |
| professions              |
| users                    |
+--------------------------+

Podemos ver algo curioso

+------------+------------------+------+-----+---------+----------------+
| Field      | Type             | Null | Key | Default | Extra          |
+------------+------------------+------+-----+---------+----------------+
| id         | int(10) unsigned | NO   | PRI | NULL    | auto_increment |
| title      | varchar(100)     | NO   |     | NULL    |                |
| created_at | timestamp        | YES  |     | NULL    |                |
| updated_at | timestamp        | YES  |     | NULL    |                |
+------------+------------------+------+-----+---------+----------------+


Si agregamos ahora dos porfesiones como a la tabla professions:

	- Back-end developer
	- Front-end developer

Y en la siguiente secciona veremos como podemos hacer esto con Laravel para evitar agregar estos datos manualmente una y otra vez.

<<< MySQL	
	
	INSERT INTO `professions` (`id`, `title`, `created_at`, `updated_at`) VALUES (NULL, 'Back-end developer', NULL, NULL), (NULL, 'Front-end developer', NULL, NULL);


Si ahora regresamos a la tabla de usuarios podemo ver que en la columna "profession_id" tiene una llave asociada a esta columna.

+-------------------+------------------+------+-----+---------+----------------+
| Field          	| Type             | Null | Key | Default | Extra          |
+-------------------+------------------+------+-----+---------+----------------+
| id             	| int(10) unsigned | NO   | PRI | NULL    | auto_increment |
| name           	| varchar(255)     | NO   |     | NULL    |                |
| email          	| varchar(255)     | NO   | UNI | NULL    |                |
| password       	| varchar(255)     | NO   |     | NULL    |                |
| remember_token 	| varchar(100)     | YES  |     | NULL    |                |
| created_at     	| timestamp        | YES  |     | NULL    |                |
| updated_at     	| timestamp        | YES  |     | NULL    |                |
| profession_id(*)  | int(10) unsigned | NO   | MUL | NULL    |                |
+-------------------+------------------+------+-----+---------+----------------+

En la parte inferior podemos ver el indice de esta tabla:

Keyname							Type			Unique			column 			Cardinality 			Collation 			Null 			Comment
+---------------------------+----------------+-------------+---------------+-----------------------+-------------------+-----------+----------------+
PRIMARY							BTREE			yes				id 					0 						A 				No
Users_email_unique				BTREE			yes				email				0 						A 				No
users_profession_id_foreign		BTREE			yes				profession_id		0 						A 				No


Esto no solamente va a permitir crear una relación con la tabla de profesiones, si no que hara que las busquedas relacionadas a esta columna sean mas rapidas, 

Por otro lado si yo ahora intento crear un usuario, entonces PHpmyAdmin en vez de poner una caja de texto, va a dar la opcin para seleccioanr de la tabla de profesiones.

Tal como podemos ver ahora 

Por ultimo si yo creo un usuario 

name:	Klvst3r
email: 	klvst3r@crudlaravel.io
clave. 123

>>>
	INSERT INTO `users` (`id`, `name`, `email`, `password`, `remember_token`, `created_at`, `updated_at`, `profession_id`) VALUES (NULL, 'klvst3r', 'klvst3r@crudlaravel.io', '123', NULL, NULL, NULL, '1');

Este mismo codigo puede utilizarse paa regisrar otro usuario con un email diferente pero en este caso vamos a colocar una profesion no valida, por ejemplo la profesion "50"
Ejemplo no un registro no valido

>>>

	INSERT INTO `users` (`id`, `name`, `email`, `password`, `remember_token`, `created_at`, `updated_at`, `profession_id`) VALUES (NULL, 'klvst3r', 'klvst3r@crudlaravel.io', '123', NULL, NULL, NULL, '50');

el 50 corresponde a la ultima columna que en este caso es profession_id y ahora presionamos "go". Vamos a notar lo siguiente:

Notaresmo els iguiente error:

-*-!!!
Error
SQL query:


INSERT INTO `users` (`id`, `name`, `email`, `password`, `remember_token`, `created_at`, `updated_at`, `profession_id`) VALUES (NULL, 'klvst3r', 'klvst3r@crudlaravel.io', '123', NULL, NULL, NULL, '50')
MySQL said: Documentation

#1062 - Duplicate entry 'klvst3r@crudlaravel.io' for key 'users_email_unique'


El error es por restricción de clave foranea en la base de datos, asi que de esta manera si mantiene la integridad de la base de datos, por supuesto esto es a nivel de sistemas, nosotros mas adelante vamos a neesitar, agregar validación y otros candados de seguridad, cuando trabajemos con el codigo de nuestra aplicación como tal. Eso se vera mas adelante. podemos hacer ejericios modificando tablas nuevas, utilizando el sistema de migraciones de Laravel.







Ejercicio
=========

¿Crear migraciones o modificar las ya existentes?
-------------------------------------------------

Para evitar que el número de migraciones crezca sin control, puede modificar las migraciones ya existentes. Tenga en cuenta que esto suele ser posible en etapas tempranas del desarrollo donde la base de datos no existe en producción y todos los datos son de prueba (no importa destruir y reconstruir la base de datos cada vez). Si luego de 3 meses de lanzar su proyecto debe agregar un campo a la tabla de usuarios, en este caso le recomendaría crear una migración nueva. Porque así no solo podrá modificar la tabla de usuarios (sin eliminarla y recrearla) sino que además mantendrá un historial de los cambios que se han producido en diferentes versiones de su aplicación.


Cambié una migración y ya nada funciona…
---------------------------------------
En casos donde ejecutar php artisan migrate:refresh y comandos similares, siempre produzca un error, puede solucionarlo borrando todas las tablas de su base de datos o ejecutando:
	> php artisan migrate:fresh.

Tenga en cuenta que ejecutar php artisan migrate:fresh va a eliminar todas las tablas. Hagalo solamente si no le importa perder los datos (porque solo son de prueba, etc).

Aunque podria hacer un respaldo de esa información para luego importarla, segun se requiera, siempre y cuando estructuralmente no existan cambios y los mismos dagtos no creen conflicto en el desarrollo del proyecto.



Comentarios almomento de crear llaves foraneas, aplica para versiones posteriores al a 5.5

Para los que tienen problemas en crear las llaves foranes en las nuevas versiones de Laravel utilicen o cambien la función unsignedInteger() por unsignedBigInteger()

YA NO FUNCIONA EL (unsignedInteger) en laravel 5.8-> me genero mucho estres.

Debido a que laravel ahora usa de forma predeterminada "bigIncrements", tienes que usar "unsignedBigInteger" para hacer referencias a esta columna
	o bien $table->bigInteger('id')->unsigned();



Referencias
===========

Variables de Entorno en Laravel
-------------------------------
Con el uso de las credenciales y nuestra configuración de la base de datos en el archivo .env siempre sera distinto o al menos la mayoria de las veces en un entorno local de desarrollo que en un entorno de producción, es por ello que vamos a hacer referencia al tema de "Variables de entorno en laravel" Esta referencia se encentra dentro de las referencias del capitulo 3. con el mismo nombre.



Comentarios
-----------

Comentario 1: cuando creo una tabla nueva como 'professions' que deba enlazarla a 'users' con la clave foránea 'professions_id', siento cómodo crear una migración donde dentro del mismo up() creo la tabla 'professions' y además añado en 'users' la columna 'professions_id' y la clave foránea correspondiente. En este ejercicio no se a intentado hacer así y a mí me resulta intuitivo y cómodo, pero la consulta es: ¿Puede traerme complicaciones en el futuro estructurarlo así?


Comentario 2:
Escribir el comando php artisan make:migration add_profession_id_to_users al final tambien le agregan lo siguiente table=users Para que ahorren tener que especificar la tabla despues de que se genere el archivo de migraccion.
Quedando:
	> php artisan make:migration add_profession_id_to_users --table=users

Comentario 3:
En el metodo down hay que especificarlo como un array $table->dropForeign(['profession_id']); y si no coloco [ ] genera un error cuando ejecuto el comando php artisan migrate:refresh	
	No habia notado que colocaba corchetes dentro de dropForeign([''])
	Por si ayuda tambien se puede hacer sin corchetes pero se usa el nombre de la restriccion como tal
	Por ejemplo en lugar de
	$table->dropForeign(['profession_id']);
	Uso
	$table->dropForeign('profession_id_foreign'); // Siendo profession_id_foreign el nombre que mysql le da a la restriccion	

Comentario 4:
En el archivo de migración de la tabla professions crea los siguientes campos:

Schema::create('professions', function (Blueprint $table) {
$table->increments('id');
$table->string('title');
$table->timestamps();
});

En el archivo de migración de la tabla users debes crear primero el campo profession_id para poder hacer la relacion:

$table->unsignedInteger('profession_id');
$table->foreign('profession_id')->references('id')->on('professions'); //Create foreign key

Si se intenta asi como me dices pero el problema es que no se crea la relación con la tabla professions aun puedo seguir poniendo id que no existen en dicha tabla

	Intente con los siguientes comandos

	- php artisan migrate:rollback => Para eliminar los lotes de migraciones y dejar limpia la tabla.

	- php artisan migrate:fresh => Para eliminar el contenido de las otras tablas y te ejecute de nuevo las migraciones.

Referencias:

	https://laracasts.com/series/laravel-5-fundamentals/episodes/7


	
	
	
