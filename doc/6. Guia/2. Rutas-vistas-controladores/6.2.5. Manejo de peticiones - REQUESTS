Archivos
-----

    Secciones:
        Vistas-Plantillas:
            layout.blade.php
            contacto.blade.php
            
            
        Rutas:
            routes/
                web.php
            
        Controladores
            app/Http/Controllers/
                PagesController.php

        middleware
            app/Http/Middleware/
                VerifyCsrfToken.php

Contenido:
------

En la sección anterior se reviso la forma de como utilizar controladores, ahora se veran los Requests


Requests
Re refiere a las solicitudes o peticiones HTTP que realiza el usurio a traves del navegador, vamos a ver como se procesan estas peticiones en Laravel.

En el archivo de Plantillas

layout.blade.php


Se actualizan los links con la Sitaxis de blade

    ---
        <nav>
			<a href="{{ echo route('home') }}">Inicio</a>
			<a href="{{ echo route('saludos','Klvst3r') }}">Saludo</a>
			<a href="{{ echo route('contactos') }}">Contactos</a>
		</nav>
    ---

Vamos a ver un ejemplo practico sobre el manejo de Requests, digamos que se quieren añadir estados a los links del menu, es decir que cambien, dependiendo de la página que se encunetran.

Para ello se va a crear una clase de CSS, para mostrar el menu cuando este activo.

Por comodidad se creara en el mismo layout.


 ---
    <style>
		.active{
			text-decoration: none;
			color: green;
		}
	</style>

 ---

 Con esto el link cambia a verde, ahora se usara una funcion que se llama requests, que al igual que las funcinoes, devuelve una nueva instancia de la clase en cuestion, en este caso la clase:

    Illuminate\Http\Request

A traves de esta funcion, se accedera al metodo URL que imprimi la URL actual.


---
	<h1>
			{{ request()->url() }}
		</h1>
	  
---

Refrescamos en el navegador. Esto imrpimira la URL web.

Tambien tenemos un metodo llamado is, lo que hace es preguntar si la url en la que estamos es la misma que le pasamos por parametro.

Aca no es necesario pasar la url completa.

Utilizando un operador ternario,si es verdadero imprime 
    Estas en el home
si es falso 
    No estas en el home.

---
    <h1>
			{{ request()->is('/') ? 'Estás en el Home' : 'No estas en el home' }}
		</h1>
---


En el navegador os muestra la ejecución. Con esto ya podemos saber en que pagina estamos, solo nos queda agregar la clase.

En la clase del link se repitre el operador ternario. 

---
    <a class="{{ request()->is('/') ? 'active' : '' }}" href="{{ route('home') }}">Inicio</a>
---

Si estamo en home se utiliza la clase active, en caso contrario lo dejamos en blanco.

Activandose el link solo cuando se esta en el home, se repite lo mismo con los demas links

---
<header>
		<h1>
			{{ request()->is('/') ? 'Estás en el Home' : 'No estas en el home' }}
		</h1>
		  <nav>
			<a class="{{ request()->is('/') ? 'active' : '' }}" href="{{ route('home') }}">Inicio</a>
			<a class="{{ request()->is('saludos/Klvst3r') ? 'active' : '' }}" href="{{ route('saludos','Klvst3r') }}">Saludo</a>
			<a class="{{ request()->is('contactame') ? 'active' : '' }}" href="{{ route('contactos') }}">Contactos</a>
		</nav>
	</header>
---

ahora ya se tiene una navegación dinamicam, pero si se cambia el parametro de saludo, deja de funcionar, esto es por que la url es distinta a la que se definio en el link. Para solucionar esto, se agrega un * o comodin lo que significa que se puede escribir cualquier cosa, en  lugar del asterisco  


---
    <a class="{{ request()->is('saludos/*') ? 'active' : '' }}" href="{{ route('saludos','Klvst3r') }}">Saludo</a>
---

Ahora puedo cambiar el aprametro que sea necesario.

Para evitar la repetición creamos una funcion de la siguiente maner:

---
<header>

		<header>
		<?php function activeMenu($url){
			return request()->is($url) ? 'active' : ''; 
		}

		?>
		  <nav>
			<a class="{{ activeMenu('/') }}" 
				href="{{ route('home') }}">Inicio</a>
			
			<a class="{{ activeMenu('saludos/*') }}" 
				href="{{ route('saludos','Klvst3r') }}">Saludo</a>
			
			<a class="{{ activeMenu('contactame') }}" 
				href="{{ route('contactos') }}">Contactos</a>
		</nav>
	</header>

---
 

 Verificando que aun siga funcionado todo.


Aunque es necesario decir que una vista no es un buen lugar para definir funciones.

Procesar Formularios
------------------


En la vista contacto Se crea un formulario de contacto.

Los formularios tienen por defecto un metodo get, pero ahora se va a utilizar el metodo post 

Formulario de contacto
---
---

Ahora vamos a definir la ruta que se encarga de procesar el formulario en la ruta
la url es la accion del formulario 

Ruta
---
    Route::post('contacto', 'PagesController@mensajes');
---

Controlador
---
    public function mensajes()
    {
        return 'Procesando el mensaje...';
    }
    
---

al enviar el formulario genera un error,
TikenMismatchException in VerifyCsrfToken

Este error es dispardo por un middleware, que aun es un tema no visto, por ahora solo se deshabilitar. Abruimos el middleweare

    VerifyCsrfToken.php

Tenemos una propiedad excep, Aca se va a definir la ura que no queremos que sea verifiada. No es recomendable hacer esto.

Por ahora esta bien.

protected $except = [
        'contacto'
    ];

Dentro del controlador se utilizara la calse Reuqest

---
protected $request; 
    
    public function __construct(Request $request)
    {
        $this->request = $request;
    }

---

Se tienen varias opciones, una de ellas inyectarla a trevs del constructor, de la forma anterior

En el metodo.
---
public function mensajes()
    {
        return $this->request->all();
    }
---

Acedemos a la propiedad y aca ya se puede utilizar cualquier metodo de la clase request, en este caso todos los datos con el metodo all.

Volvemos allenar el formualrio. Se envia y ahora tendremos los datos del formulario en formato JSON.

    {
    "nombre": "Klvst3r",
    "email": "klvst3r@email.com",
    "mensaje": "Mi mensaje"
    }

Ahora si solo vamos a utilziar la clase request en este metoso  Se puede tambien inyectar directamente desde PagesController



De la siguiente forma, se borra el constructor. Y en el metodo inyectamos la clase, laravel automaticamente resolvera la clase y la asignara a la variable Reuqest, y ya se podra utilizar en el metodo mensaje.

---
 public function mensajes(Request $request)
    {
        return $request->all(); 
    }
    
---

Obteniendo la misma respuesta en formato JSON


Validación de campos en formulario
------


Tambien se puede revisar si un campo fue llenado o no
En el controlador 
--
  public function mensajes(Request $request)
    {
     
        if($request->has('nombre'))
        {
            return "Si tiene nombre";
        }

        return "No tiene nombre";
    }

Con un if preguntamos si la peticion tiene nombre con el metodo has y solo se devuelme mensaje si tiene nombre, caso contrario no tiene nombre.

si envio el formlario sin nombre, indica no tiene nombre, si se agrega, si tiene nombre,


Tambien se puede acceder a un campo especifico

---
   public function mensajes(Request $request)
    {

        return $request->all();

        if($request->has('nombre'))
        {
            return "Si tiene nombre";
        }

        return "No tiene nombre";
        

    }
--

Tambien se puede acceder a un campo especifico, con el nombre del campo

---
if($request->has('nombre'))
        {
            return "Si tiene nombre. Es " . $request->input('nombre');

        }
            return "No tiene nombre";

---

De esta forma se pueden validar formularios de forma manual, sin embargo Laravel, tiene su propio sistema de validación.

Se vera en la siguiente seccion