31. Usando Eloquent ORM de forma interactiva con Tinker
-------------------------------------------------------


Notas:
======
En esta Seccion se aprendera a interactuar desde la terminal con nuestra aplicación utilizando la consola dinámica Tinker. También veremos nuevos métodos de Eloquent para interactuar con nuestros modelos y aprenderemos cómo crear nuestros propios métodos dentro de los modelos.

Vayamos a cada seccion:



Acceder a Tinker
----------------

Podemos acceder al entorno con el comando de Artisan «tinker»:
	> php artisan tinker

Desde el entorno interactivo podemos ejecutar expresiones de PHP y también vamos a tener disponible las clases de nuestro proyecto y del framework.




Retornar todos los registros con el método all()
------------------------------------------------

Utilizando el «método all()» retornamos todos los registros asociados a un modelo:
---
	$professions = Profession::all();
---



Los métodos «all()» y «get()» en Eloquent retornan colecciones «(objetos de la clase Illuminate\Database\Eloquent\Collection)» las cuales «envuelven» el array de resultados y nos proveen de funciones y métodos adicionales, por ejemplo:

Podemos obtener el primer resultado utilizando el método «first()» y el último utilizando el método «last()». También podemos obtener un resultado aleatorio utilizando el método «random()»:

---
	$profession->first(); // Obtenemos el primer resultado
	$profession->last(); // Obtenemos el último resultado
	$profession->random(1); // Obtenemos un resultado aleatorio
---



Estos métodos de la clase Collection no generan nuevas consultas SQL sino que operan sobre los resultados ya encontrados.




Seleccionar un campo con el método pluck()
------------------------------------------

Utilizando el método «pluck()» podemos retornar una nueva colección que contenga un listado de un solo campo en vez de un listado de objetos. Por ejemplo, podemos obtener solo el campo title de la siguiente forma:

---
	$professions->pluck('title');
---


	Devuelve:
---
	=> Illuminate\Support\Collection {#736
	     all: [
	       "Desarrollador back-end",
	       "Desarrollador front-end",
	       "Diseñador web",
	     ],
	   }
---



Crear una colección de forma manual
-----------------------------------

Con el helper «collect» podemos crear una colección de forma manual:
---
	collect(['Klvst3r', 'crudlaravel', 'Laravel']);
--


Sin embargo éste será un objeto de la clase «Illuminate\Support\Collection» que representa la colección «base» en vez de «Illuminate\Database\Eloquent\Collection».


	## Las colecciones de Eloquent extienden de la colección «base» pero proveen algunos métodos extra asociados al ORM ##



Declarar métodos en el modelo
=============================

Podemos declarar métodos dentro de un modelo y utilizarlos cuando interactuemos con los objetos de estos modelos:


Declarando métodos no estáticos:
--------------------------------

Asociamos un método para ser utilizado sobre un objeto (que representa un registro de la base de datos):
---
	public function isAdmin()
	{
	    return $this->email === 'klvst3r@mail.com';
	}
---


En este caso «isAdmin()» devuelve true si el email del usuario es igual al valor con el que está siendo comparado:
---
	$user = User::find(1);
	$user->isAdmin(); // Devuelve true o false
---


Declarando métodos estáticos:
-----------------------------

Asociamos un método a la clase del modelo como tal, la cual representa el acceso a una tabla de la base de datos. Estos métodos son usados típicamente para consultas:

---
public static function findByEmail($email)
{
    return static::where('email', $email)->first();
}
---

Luego podrás usar «User::findbyEmail('email@aqui.com')» para buscar a un usuario por el campo email y obtener un objeto «User» como resultado (o «null» si no se encuentra ningún registro).





Practica:
=========

Dentro de los multiples beneficios que trae trabajar con el Framework de Laravel, se encuentra el entorno de programación interactiva llamada «Tinker» se puede acceder a dicho entorno con el comando desde la consola y desde el directorio del proyecto:
	> php artisan thinker

Al presionar «enter» ya se esta dentro del entorno interactivo. Desde aca se pueden ejecutar expresiones de PHP por ejemplo se quiere imprimir 

	$ php artisan tinker
	Psy Shell v0.9.12 (PHP 7.3.10 — cli) by Justin Hileman
	>>> echo "Hello world";
	Hello world⏎
	>>>

Observandose el resultado, pero lo más interesante no es que puedan ejecutarse expresioens de PHP, sino que se tienes disponibles las clases del proyecto y del Framework de Laravel. Por ejemplo ahora se puede intyeractuar con el modelo de «profesioens» de Laravel, de la siguiente manera:


Este metodo «all()» no se ha visto hasta ahora, pero básicamente permite obtener todos los registros asociados a este modelo, en este caso todos los registros dentro de la tabla Professions, al precionar «enter».


*** Problema
	Al ejecutar la consola de Tinker marca el siguiente error:

	$ php artisan tinker
	Psy Shell v0.9.12 (PHP 7.3.10 — cli) by Justin Hileman
	>>> Profession::all()
	PHP Fatal error:  Class 'Profession' not found in Psy Shell code on line 1


esa característica de Tinker es un poco experimental y está allí por comodidad o como último recurso, si no te funciona simplemente coloca el nombre de espacio completo App\Profession.

También podrías intentar con el siguiente comando
	> composer dump-autoload.


Posterior a la generación de aerchivos optimizados se vulve a intentar utilizando exclusivamente la segunda opción.

Volvemos a ejecutar


	> php artisan tinker
	Psy Shell v0.9.12 (PHP 7.3.10 — cli) by Justin Hileman
	>>> Profession::all();
	[!] Aliasing 'Profession' to 'App\Models\Profession' for this Tinker session.
	PHP Deprecated:  The "Doctrine/Common/Inflector/Inflector::pluralize" method is deprecated and will be dropped in doctrine/inflector 2.0. Please update to the n
	ew Inflector API. in C:/AppServ/www/dev/CRUDLaravel5.5/vendor/doctrine/inflector/lib/Doctrine/Common/Inflector/Inflector.php on line 264
	PHP Deprecated:  The "Doctrine/Common/Inflector/Inflector::pluralize" method is deprecated and will be dropped in doctrine/inflector 2.0. Please update to the n
	ew Inflector API. in C:/AppServ/www/dev/CRUDLaravel5.5/vendor/doctrine/inflector/lib/Doctrine/Common/Inflector/Inflector.php on line 264
	=> Illuminate\Database\Eloquent\Collection {#4121
	     all: [
	       App\Models\Profession {#4122
	         id: 1,
	         title: "Back-end developer",
	         created_at: "2022-06-22 22:51:50",
	         updated_at: "2022-06-22 22:51:50",
	       },
	       App\Models\Profession {#4123
	         id: 2,
	         title: "Front-end developer",
	         created_at: "2022-06-22 22:51:50",
	         updated_at: "2022-06-22 22:51:50",
	       },
	       App\Models\Profession {#4124
	         id: 3,
	         title: "Web Designer",
	         created_at: "2022-06-22 22:51:50",
	         updated_at: "2022-06-22 22:51:50",
	       },
	     ],
	   }
	>>>



Debo advertir que en mi caso existen dos modelos en la siguiente rutas
1. El generado en el ejemplo numero 1 situado en la siguiente ruta:
	\App\

2. El segundo se genero dentro de una Carpeta lamada "Models"
	Por lo que esta en \App\Models\Profession

Laravel toma como base el segundo para la sección correspondiente de esta guia.


***

Notemos que en este caso utilizaremos para importar la clase antes de utilizarla 
 	use App\Models\Profession;
---
Posterior a ello podremos ejecutar el comando requerido sin ninguna compliación
	>>> Profession::all();
	
---

Ejecutamos:
	> php artisan tinker
	Psy Shell v0.9.12 (PHP 7.3.10 — cli) by Justin Hileman

	>>> use App\Models\Profession;

	>>> Profession::all();
	PHP Deprecated:  The "Doctrine/Common/Inflector/Inflector::pluralize" method is deprecated and will be dropped in doctrine/inflector 2.0. Please update to the new Inflector API. in C:/AppServ/www/dev/CRUDLaravel5.5/vendor/doctrine/inflector/lib/Doctrine/Common/Inflector/Inflector.php on line 264
	PHP Deprecated:  The "Doctrine/Common/Inflector/Inflector::pluralize" method is deprecated and will be dropped in doctrine/inflector 2.0. Please update to the new Inflector API. in C:/AppServ/www/dev/CRUDLaravel5.5/vendor/doctrine/inflector/lib/Doctrine/Common/Inflector/Inflector.php on line 264
	=> Illuminate\Database\Eloquent\Collection {#4124
	     all: [
	       App\Models\Profession {#4125
	         id: 1,
	         title: "Back-end developer",
	         created_at: "2022-06-22 22:51:50",
	         updated_at: "2022-06-22 22:51:50",
	       },
	       App\Models\Profession {#4126
	         id: 2,
	         title: "Front-end developer",
	         created_at: "2022-06-22 22:51:50",
	         updated_at: "2022-06-22 22:51:50",
	       },
	       App\Models\Profession {#4127
	         id: 3,
	         title: "Web Designer",
	         created_at: "2022-06-22 22:51:50",
	         updated_at: "2022-06-22 22:51:50",
	       },
	     ],
	   }
	>>> exit


---

Notemos que podemos salir de la consola interactiva con el comando de tinker:

	>>> exit

Para volver a entrar a Tinker
	> php artisan tinker

	>>> use App\Models\Profession;

En este caso importamos con use y luego lo utilizamos
	$ php artisan tinker
	Psy Shell v0.9.12 (PHP 7.3.10 — cli) by Justin Hileman
	>>> use App\Models\Profession;
	>>> Profession::all();
	PHP Deprecated:  The "Doctrine/Common/Inflector/Inflector::pluralize" method is deprecated and will be dropped in doctrine/inflector 2.0. Please update to the new Inflector API. in C:/AppServ/www/dev/CRUDLaravel5.5/vendor/doctrine/inflector/lib/Doctrine/Common/Inflector/Inflector.php on line 264
	PHP Deprecated:  The "Doctrine/Common/Inflector/Inflector::pluralize" method is deprecated and will be dropped in doctrine/inflector 2.0. Please update to the new Inflector API. in C:/AppServ/www/dev/CRUDLaravel5.5/vendor/doctrine/inflector/lib/Doctrine/Common/Inflector/Inflector.php on line 264
	=> Illuminate\Database\Eloquent\Collection {#4122
	     all: [
	       App\Models\Profession {#4123
	         id: 1,
	         title: "Back-end developer",
	         created_at: "2022-06-22 22:51:50",
	         updated_at: "2022-06-22 22:51:50",
	       },
	       App\Models\Profession {#4124
	         id: 2,
	         title: "Front-end developer",
	         created_at: "2022-06-22 22:51:50",
	         updated_at: "2022-06-22 22:51:50",
	       },
	       App\Models\Profession {#4125
	         id: 3,
	         title: "Web Designer",
	         created_at: "2022-06-22 22:51:50",
	         updated_at: "2022-06-22 22:51:50",
	       },
	     ],
	   }
	>>> exit;

	
Ahora si salgo y me vuelvo a conectar a Tinker tambien se puede utilizar el nombre de espacio completo de la siguiente manera;

	>>> App\Models\Profession::all();
	PHP Deprecated:  The "Doctrine/Common/Inflector/Inflector::pluralize" method is deprecated and will be dropped in doctrine/inflector 2.0. Please update to the new Inflector API. in C:/AppServ/www/dev/CRUDLaravel5.5/vendor/doctrine/inflector/lib/Doctrine/Common/Inflector/Inflector.php on line 264
	PHP Deprecated:  The "Doctrine/Common/Inflector/Inflector::pluralize" method is deprecated and will be dropped in doctrine/inflector 2.0. Please update to the new Inflector API. in C:/AppServ/www/dev/CRUDLaravel5.5/vendor/doctrine/inflector/lib/Doctrine/Common/Inflector/Inflector.php on line 264
	=> Illuminate\Database\Eloquent\Collection {#4129
	     all: [
	       App\Models\Profession {#4128
	         id: 1,
	         title: "Back-end developer",
	         created_at: "2022-06-22 22:51:50",
	         updated_at: "2022-06-22 22:51:50",
	       },
	       App\Models\Profession {#4127
	         id: 2,
	         title: "Front-end developer",
	         created_at: "2022-06-22 22:51:50",
	         updated_at: "2022-06-22 22:51:50",
	       },
	       App\Models\Profession {#4134
	         id: 3,
	         title: "Web Designer",
	         created_at: "2022-06-22 22:51:50",
	         updated_at: "2022-06-22 22:51:50",
	       },
	     ],
	   }
	>>>


Por ultimo, si se esta generando error al escribir unicamente Profession, como fue nuestro caso, podemos ejecutar:
	> composer dump-autoload
	Generating optimized autoload files
	Carbon 1 is deprecated, see how to migrate to Carbon 2.
	https://carbon.nesbot.com/docs/#api-carbon-2
	    You can run ".\vendor\bin\upgrade-carbon" to get help in updating carbon and other frameworks and libraries that depend on it.
	> Illuminate\Foundation\ComposerScripts::postAutoloadDump
	> @php artisan package:discover
	Discovered Package: fideloper/proxy
	Discovered Package: laravel/tinker
	Discovered Package: nesbot/carbon
	Package manifest generated successfully.
	Generated optimized autoload files containing 3550 classes


Y luego conectar con tiknker y volver a intentarlo:
	> php artisan tinker
	Psy Shell v0.9.12 (PHP 7.3.10 — cli) by Justin Hileman
	>>> Profession::all();
	[!] Aliasing 'Profession' to 'App\Models\Profession' for this Tinker session.
	PHP Deprecated:  The "Doctrine/Common/Inflector/Inflector::pluralize" method is deprecated and will be dropped in doctrine/inflector 2.0. Please update to the new Inflector API. in C:/AppServ/www/dev/CRUDLaravel5.5/vendor/doctrine/inflector/lib/Doctrine/Common/Inflector/Inflector.php on line 264
	PHP Deprecated:  The "Doctrine/Common/Inflector/Inflector::pluralize" method is deprecated and will be dropped in doctrine/inflector 2.0. Please update to the new Inflector API. in C:/AppServ/www/dev/CRUDLaravel5.5/vendor/doctrine/inflector/lib/Doctrine/Common/Inflector/Inflector.php on line 264
	=> Illuminate\Database\Eloquent\Collection {#4121
	     all: [
	       App\Models\Profession {#4122
	         id: 1,
	         title: "Back-end developer",
	         created_at: "2022-06-22 22:51:50",
	         updated_at: "2022-06-22 22:51:50",
	       },
	       App\Models\Profession {#4123
	         id: 2,
	         title: "Front-end developer",
	         created_at: "2022-06-22 22:51:50",
	         updated_at: "2022-06-22 22:51:50",
	       },
	       App\Models\Profession {#4124
	         id: 3,
	         title: "Web Designer",
	         created_at: "2022-06-22 22:51:50",
	         updated_at: "2022-06-22 22:51:50",
	       },
	     ],
	   }
	>>>


Con este componente vamos a poder hacer nuestras pruebas directamente desde la consola sin necesidad de escribir Seeders, sin reejecutarlos o de hacer pruebas en el navegador; sino que se podran ver los resultados inmediatamante.

Es conveniente por que se van a explicar algunos puntos que es mas facil visualizarlos en la consola, en este caso cuando llamemos al metodo «all()» o incluso al metodo «get()».

Ejecutamos:
	 >>> Profession::get();
	 [!] Aliasing 'Profession' to 'App\Models\Profession' for this Tinker session.
	PHP Deprecated:  The "Doctrine/Common/Inflector/Inflector::pluralize" method is deprecated and will be dropped in doctrine/inflector 2.0. Please update to the new Inflector API. in C:/AppServ/www/dev/CRUDLaravel5.5/vendor/doctrine/inflector/lib/Doctrine/Common/Inflector/Inflector.php on line 264
	PHP Deprecated:  The "Doctrine/Common/Inflector/Inflector::pluralize" method is deprecated and will be dropped in doctrine/inflector 2.0. Please update to the new Inflector API. in C:/AppServ/www/dev/CRUDLaravel5.5/vendor/doctrine/inflector/lib/Doctrine/Common/Inflector/Inflector.php on line 264
	=> Illuminate\Database\Eloquent\Collection {#4121
	     all: [
	       App\Models\Profession {#4122
	         id: 1,
	         title: "Back-end developer",
	         created_at: "2022-06-22 22:51:50",
	         updated_at: "2022-06-22 22:51:50",
	       },
	       App\Models\Profession {#4123
	         id: 2,
	         title: "Front-end developer",
	         created_at: "2022-06-22 22:51:50",
	         updated_at: "2022-06-22 22:51:50",
	       },
	       App\Models\Profession {#4124
	         id: 3,
	         title: "Web Designer",
	         created_at: "2022-06-22 22:51:50",
	         updated_at: "2022-06-22 22:51:50",
	       },
	     ],
	   }
	>>>

Para obtener las profesiones sin importar si nosostros estamos utlizando un codicional u otro parametro para ejecutar las consultas. Nosotros vamos a recibir como resultado un objeto de la clase "Collection" como se aprecio de la extracción del comando anterior:

---
	=> Illuminate\Database\Eloquent\Collection {#4121


Podemos ver erl nombre de espacio completo, como explicamos anteriormente una colección permite	devolver un array de datos, en este caso es un array que contienen objetos de la clase "Profession" eso se explicara en breve, la idea es trabajar con una interfaz orientada o objetos y tener funcionalidades adicionales que no estan inlcuidas en los array por defecto que trae PHP por ejemplo:

Se declara una variable que va a ser igual al resultado de llamar al metodo all() en el modelo Profession.


	>>> $professions = Profession::all();
	[!] Aliasing 'Profession' to 'App\Models\Profession' for this Tinker session.
	PHP Deprecated:  The "Doctrine/Common/Inflector/Inflector::pluralize" method is deprecated and will be dropped in doctrine/inflector 2.0. Please update to the new Inflector API. in C:/AppServ/www/dev/CRUDLaravel5.5/vendor/doctrine/inflector/lib/Doctrine/Common/Inflector/Inflector.php on line 264
	PHP Deprecated:  The "Doctrine/Common/Inflector/Inflector::pluralize" method is deprecated and will be dropped in doctrine/inflector 2.0. Please update to the new Inflector API. in C:/AppServ/www/dev/CRUDLaravel5.5/vendor/doctrine/inflector/lib/Doctrine/Common/Inflector/Inflector.php on line 264
	=> Illuminate\Database\Eloquent\Collection {#4121
	     all: [
	       App\Models\Profession {#4122
	         id: 1,
	         title: "Back-end developer",
	         created_at: "2022-06-22 22:51:50",
	         updated_at: "2022-06-22 22:51:50",
	       },
	       App\Models\Profession {#4123
	         id: 2,
	         title: "Front-end developer",
	         created_at: "2022-06-22 22:51:50",
	         updated_at: "2022-06-22 22:51:50",
	       },
	       App\Models\Profession {#4124
	         id: 3,
	         title: "Web Designer",
	         created_at: "2022-06-22 22:51:50",
	         updated_at: "2022-06-22 22:51:50",
	       },
	     ],
	   }
	>>>


Ahora se puede limpiar la consola ahora se puede obtener la primera profesion de la siguiente manera:

	>>> $professions->first();
	PHP Notice:  Undefined variable: professoins in C:/AppServ/www/dev/CRUDLaravel5.5eval()'d code on line 1
	>>> $professions->first();
	=> App\Models\Profession {#4122
	     id: 1,
	     title: "Back-end developer",
	     created_at: "2022-06-22 22:51:50",
	     updated_at: "2022-06-22 22:51:50",
	   }

 
Utilizando el metodo «first()». Notemos que la primera profession tiene el id:1 y el titulo: "Back-end developer", Pero como podemos imaginar tambien podemos obtener la ultima profesión en esta caso llamando al metodo «last()»

	>>> $professions->last();
	=> App\Models\Profession {#4125
	     id: 3,
	     title: "Web Designer",
	     created_at: "2022-06-22 22:51:50",
	     updated_at: "2022-06-22 22:51:50",
	   }


Podemos ver que la ultima profesion que se creo tiene el id: 3 y el titulo: "Web Designer"

Tambien podemos obtener una profesion de forma aleatoria de la siguiente manera:

  		>>> $professions->random(1);
		=> App\Models\Profession {#4124
		     id: 3,
		     title: "Web Designer",
		     created_at: "2022-06-22 22:51:50",
		     updated_at: "2022-06-22 22:51:50",
		   }


En este caso obtenemos una colección aleatoria con una profesion aleatoria, y podemos omitir el argumento (1) y en este caso este metodo va a retornar un solo objeto de la clase Profession


	>>> $professions->random(1);
	=> Illuminate\Database\Eloquent\Collection {#3191
	     all: [
	       App\Models\Profession {#4122
	         id: 1,
	         title: "Back-end developer",
	         created_at: "2022-06-22 22:51:50",
	         updated_at: "2022-06-22 22:51:50",
	       },
	     ],
	   }
	>>> 


Hay muchs operaciones que podemos hacer cuando trabajamos con colecciones; por ejemplo, vamos a suponer que nos interesa obtener unicamente el campo "title".


En este caso podemos utilizar el metodo «pluck()». 

	>>> $professions->pluck('title');
	=> Illuminate\Support\Collection {#3185
	     all: [
	       "Back-end developer",
	       "Front-end developer",
	       "Web Designer",
	     ],
	   }
	>>>


Aca nuevamente obtenemos una colecion como resultado pero notemos que el array de datos ya no contiene objetos de la clase Profession, sino que contiene cadenas de texto, y cada titulo es una cadena. Esto se logra con el metodo «pluck()». 


Las coleciones de Laravel tambien son inmutables, es decir que por ejemplo para llamar a este metodo no va a modificar mi coleccion original, 


	>>> $professions
	=> Illuminate\Database\Eloquent\Collection {#4121
	     all: [
	       App\Models\Profession {#4122
	         id: 1,
	         title: "Back-end developer",
	         created_at: "2022-06-22 22:51:50",
	         updated_at: "2022-06-22 22:51:50",
	       },
	       App\Models\Profession {#4123
	         id: 2,
	         title: "Front-end developer",
	         created_at: "2022-06-22 22:51:50",
	         updated_at: "2022-06-22 22:51:50",
	       },
	       App\Models\Profession {#4124
	         id: 3,
	         title: "Web Designer",
	         created_at: "2022-06-22 22:51:50",
	         updated_at: "2022-06-22 22:51:50",
	       },
	     ],
	   }
	>>>


Vamos a probar nuevamante.

Vamos a declarar otra veiable llamada $titles para almacenar la coleccion con los titulos de las profesiones, ahora podemos ver el objeto que tengo almacenado en la variable $titles, Pero podemos fijarnos que el objeto que se tiene almacenado en la variable "$professions" no cambia.


	>>> $professions;
	=> Illuminate\Database\Eloquent\Collection {#4122
	     all: [
	       App\Models\Profession {#4123
	         id: 1,
	         title: "Back-end developer",
	         created_at: "2022-06-22 22:51:50",
	         updated_at: "2022-06-22 22:51:50",
	       },
	       App\Models\Profession {#4124
	         id: 2,
	         title: "Front-end developer",
	         created_at: "2022-06-22 22:51:50",
	         updated_at: "2022-06-22 22:51:50",
	       },
	       App\Models\Profession {#4125
	         id: 3,
	         title: "Web Designer",
	         created_at: "2022-06-22 22:51:50",
	         updated_at: "2022-06-22 22:51:50",
	       },
	     ],
	   }
	>>> $titles = $professions->pluck('title');
	=> Illuminate\Support\Collection {#3193
	     all: [
	       "Back-end developer",
	       "Front-end developer",
	       "Web Designer",
	     ],
	   }
	>>> $titles
	=> Illuminate\Support\Collection {#3193
	     all: [
	       "Back-end developer",
	       "Front-end developer",
	       "Web Designer",
	     ],
	   }
	>>>



De igual forma si yo utilizo "$random()", opara obtener dos profesiones aleatorias de la siguiente manera. como en mi caso que he hecho un pasusa desde un dia anterior, tendria que ejecutar la siguiente secuela en este orden:

	> php artisan tinker

	>>> $professions = Profession::all();

	>>> $professions->random(1);

Y la linea a ejecutar finalemnte seria:


	>>> $randomProfessions = $professions->random(2);
	=> Illuminate\Database\Eloquent\Collection {#3197
	     all: [
	       App\Models\Profession {#4126
	         id: 2,
	         title: "Front-end developer",
	         created_at: "2022-06-22 22:51:50",
	         updated_at: "2022-06-22 22:51:50",
	       },
	       App\Models\Profession {#4127
	         id: 3,
	         title: "Web Designer",
	         created_at: "2022-06-22 22:51:50",
	         updated_at: "2022-06-22 22:51:50",
	       },
	     ],
	   }
	>>>

Nuevamente la colección original es y no ha cambiado como podemos observar:

	>>> $professions
	=> Illuminate\Database\Eloquent\Collection {#4122
	     all: [
	       App\Models\Profession {#4123
	         id: 1,
	         title: "Back-end developer",
	         created_at: "2022-06-22 22:51:50",
	         updated_at: "2022-06-22 22:51:50",
	       },
	       App\Models\Profession {#4124
	         id: 2,
	         title: "Front-end developer",
	         created_at: "2022-06-22 22:51:50",
	         updated_at: "2022-06-22 22:51:50",
	       },
	       App\Models\Profession {#4125
	         id: 3,
	         title: "Web Designer",
	         created_at: "2022-06-22 22:51:50",
	         updated_at: "2022-06-22 22:51:50",
	       },
	     ],
	   }



si necesitamos saber más sobre los metodos disponibles que tenemos para trabajar con colecciones podemos revisar la documentación siguiente de Laravel, en ella se tiene una larga lista de metodos que estan disponibles cuando trabajamos con colecciones :

	https://laravel.com/docs/5.5/eloquent-collections

La mayoria de ellos son bien utiles y es importanmte señalar que Laravel tiene dos colecciones.

- Una colección de eloquent que es lo que obtenemos cuando hacemos una bsqueda utilizando Eloquent y 
- La segunda colección base, este caso de la colección base, estan en la colección de eloquent.

En la documentación podemos ver la documentación de las colecciones base, tambien Laravel nos enseña como nosotros podemos crear nuestras propias colecciones, por ejemplo al regresar a la consola, y utilizar el helper "collect()" para crear una colección.

	>>>collect(['Klvst3r', 'CRUD', 'Laravel']);
	=> Illuminate\Support\Collection {#3198
	     all: [
	       "Klvst3r",
	       "CRUD",
	       "Laravel",
	     ],
	   }
	>>>

		


notemos que el resultado obtenido es un objeto de la clase collecion, pero la clase varia ya no es Eloquent ahora es:
	=> Illuminate\Support\Collection {#3198

Si invocamos a nuestra colección anterior:


	>>> $professions
	=> Illuminate\Database\Eloquent\Collection {#4121
	     all: [
	       App\Models\Profession {#4122
	         id: 1,
	         title: "Back-end developer",
	         created_at: "2022-06-22 22:51:50",
	         updated_at: "2022-06-22 22:51:50",
	       },
	       App\Models\Profession {#4123
	         id: 2,
	         title: "Front-end developer",
	         created_at: "2022-06-22 22:51:50",
	         updated_at: "2022-06-22 22:51:50",
	       },
	       App\Models\Profession {#4124
	         id: 3,
	         title: "Web Designer",
	         created_at: "2022-06-22 22:51:50",
	         updated_at: "2022-06-22 22:51:50",
	       },
	     ],
	   }



Y podemos ver la diferencia con esta colección que señala la ruta.

	=> Illuminate\Database\Eloquent\Collection {#4121


La clase Eloquent\Collection extiende de la clase base \Colection sin embargo, no todos los metodos de Eloquent retornan colecciones, vamos a suponer que yo quiero encontrar la profesions "Back-end developer", en ese caso yo pudo nuevamente utilizar el modelo "Profession" y puedo realizar una busqueda utilizando el metodo "where()", de la siguiente manera que ya hemos aprendido.


	>>> $backendDeveloper = Profession::where('title', 'Back-end developer')->first();
	PHP Deprecated:  The "Doctrine/Common/Inflector/Inflector::pluralize" method is deprecated and will be dropped in doctrine/inflector 2.0. Please update to the new Inflector API. in C:/AppServ/www/dev/CRUDLaravel5.5/vendor/doctrine/inflector/lib/Doctrine/Common/Inflector/Inflector.php on line 264
	PHP Deprecated:  The "Doctrine/Common/Inflector/Inflector::pluralize" method is deprecated and will be dropped in doctrine/inflector 2.0. Please update to the new Inflector API. in C:/AppServ/www/dev/CRUDLaravel5.5/vendor/doctrine/inflector/lib/Doctrine/Common/Inflector/Inflector.php on line 264
	=> App\Models\Profession {#3191
	     id: 1,
	     title: "Back-end developer",
	     created_at: "2022-06-22 22:51:50",
	     updated_at: "2022-06-22 22:51:50",
	   }
	>>>



En este caso si yo llamo al metodo "get()" voy a obtener una colección de resultados, asi esta colección tenga un solo resultado, incluso ningun resultado voy a obtener un objeto de la clase "Eloquent" Colecction. Pero si aa llamamos al metodo "first()" en este caso vamos a obtener un solo objeto. y puesto que estamos utilizando Eloquent este va a ser un objeto del modelo en cuestion, en este caso un objeto de la clase "App\Models\Profession".

	=> App\Models\Profession {#3191



Notemos que con el constructor de consultas y hacemos lo siguiente:

	>>>DB::table('professions')->where('title', 'Back-end developer')->first();
	=> {#3911
	     +"id": 1,
	     +"title": "Back-end developer",
	     +"created_at": "2022-06-22 22:51:50",
	     +"updated_at": "2022-06-22 22:51:50",
	   }
	>>>


Que es practicamente la misma consulta pero no 	se esta utilizando Eloquent.

En este caso, el resultado es un objeto, un objeto de la clase estandar de PHP, no un modelo de Eloquent. Y esta es una diferencia muy importante. Para demostrar el por que, trabajaremos rapidamente con el modelo de usuario. En este caso obtendremos el primer usuario que se tiene en la base de datos.


	>>> $user = User::first();
	[!] Aliasing 'User' to 'App\User' for this Tinker session.
	PHP Deprecated:  The "Doctrine/Common/Inflector/Inflector::pluralize" method is deprecated and will be dropped in doctrine/inflector 2.0. Please update to the new Inflector API. in C:/AppServ/www/dev/CRUDLaravel5.5/vendor/doctrine/inflector/lib/Doctrine/Common/Inflector/Inflector.php on line 264
	PHP Deprecated:  The "Doctrine/Common/Inflector/Inflector::pluralize" method is deprecated and will be dropped in doctrine/inflector 2.0. Please update to the new Inflector API. in C:/AppServ/www/dev/CRUDLaravel5.5/vendor/doctrine/inflector/lib/Doctrine/Common/Inflector/Inflector.php on line 264
	=> App\User {#4127
	     id: 1,
	     name: "Klvst3r",
	     email: "klvst3r@email.com",
	     created_at: "2022-06-22 22:51:51",
	     updated_at: "2022-06-22 22:51:51",
	     profession_id: 1,
	   }
	>>>


O como en este caso se que el primer usuario tiene el id:1, voy a obtenerlo de la siguiente manera. Utilizando el metodo "find()" en lugar del metodo "first()". 

	>>> $user = User::find(1);
	PHP Deprecated:  The "Doctrine/Common/Inflector/Inflector::pluralize" method is deprecated and will be dropped in doctrine/inflector 2.0. Please update to the new Inflector API. in C:/AppServ/www/dev/CRUDLaravel5.5/vendor/doctrine/inflector/lib/Doctrine/Common/Inflector/Inflector.php on line 264
	PHP Deprecated:  The "Doctrine/Common/Inflector/Inflector::pluralize" method is deprecated and will be dropped in doctrine/inflector 2.0. Please update to the new Inflector API. in C:/AppServ/www/dev/CRUDLaravel5.5/vendor/doctrine/inflector/lib/Doctrine/Common/Inflector/Inflector.php on line 264
	PHP Deprecated:  The "Doctrine/Common/Inflector/Inflector::pluralize" method is deprecated and will be dropped in doctrine/inflector 2.0. Please update to the n
	ew Inflector API. in C:/AppServ/www/dev/CRUDLaravel5.5/vendor/doctrine/inflector/lib/Doctrine/Common/Inflector/Inflector.php on line 264
	=> App\User {#3911
	     id: 1,
	     name: "Klvst3r",
	     email: "klvst3r@email.com",
	     created_at: "2022-06-22 22:51:51",
	     updated_at: "2022-06-22 22:51:51",
	     profession_id: 1,
	   }
	>>>



Este metodo va a detectar como argumento, el id: en este caso el id que se quiere buscar, en este caso al ide primario de la tabla en esta caso Users o asociada al modelo "User".
	
	\App\User.php


Se obtiene el mismo resultado de antes un objeto de la clase User ahora como este es un objeto de esta clase nada impide regresar al editor y declarar metodos dentro de la Clase user para luego poder utilizarlos. Por ejemplo en el modelo "User.php" se va adeclarar a un nuevo metodo llamado «isAdmin()» va a ser un metodo publico y va retornar el resultado de comparar el email del usario con el 'klvst3r@email.com'

---\App\User.php
...
public function isAdmin(){
        return $this->email === 'klvst3r@email.com';
    }
    
...    
---

Quiere decir que este usuario es un administrador, regresando a la consola:

Se llama al metodo "isAdmin()":

	
	
En este caso se espera un error

	>>> $user->isAdmin();
	PHP Deprecated:  The "Doctrine/Common/Inflector/Inflector::pluralize" method is deprecated and will be dropped in doctrine/inflector 2.0. Please update to the new Inflector API. in C:/AppServ/www/dev/CRUDLaravel5.5/vendor/doctrine/inflector/lib/Doctrine/Common/Inflector/Inflector.php on line 264
	BadMethodCallException with message 'Call to undefined method Illuminate/Database/Query/Builder::isAdmin()'


Indica que el metodo no esta definido.Para que este metodo este definido, necesitamos salirnos de Tinker por un momento y volver a ejecutar 
	> php artisan tinker

Ahora tal como antes vamos a obtener el primer usuario registrado, que por ahora es el unico usuario que esta registrado en este momento, 	 

	>>> $user = User::find(1);
	[!] Aliasing 'User' to 'App\User' for this Tinker session.
	PHP Deprecated:  The "Doctrine/Common/Inflector/Inflector::pluralize" method is deprecated and will be dropped in doctrine/inflector 2.0. Please update to the new Inflector API. in C:/AppServ/www/dev/CRUDLaravel5.5/vendor/doctrine/inflector/lib/Doctrine/Common/Inflector/Inflector.php on line 264
	PHP Deprecated:  The "Doctrine/Common/Inflector/Inflector::pluralize" method is deprecated and will be dropped in doctrine/inflector 2.0. Please update to the new Inflector API. in C:/AppServ/www/dev/CRUDLaravel5.5/vendor/doctrine/inflector/lib/Doctrine/Common/Inflector/Inflector.php on line 264
	PHP Deprecated:  The "Doctrine/Common/Inflector/Inflector::pluralize" method is deprecated and will be dropped in doctrine/inflector 2.0. Please update to the new Inflector API. in C:/AppServ/www/dev/CRUDLaravel5.5/vendor/doctrine/inflector/lib/Doctrine/Common/Inflector/Inflector.php on line 264
	=> App\User {#3514
	     id: 1,
	     name: "Klvst3r",
	     email: "klvst3r@email.com",
	     created_at: "2022-06-22 22:51:51",
	     updated_at: "2022-06-22 22:51:51",
	     profession_id: 1,
	   }
	>>>

Y posterior a ello vamos a llamar al metodo "isAdmin()"


En este caso me esta marcando un error por que la declaración se realizo en el modelo User de la siguiente ruta "\App\User.php", pero la ruta que estamos utilizando es: "\App\Models\User.php" que se inicializo al comenzo de esta sección. Pr ello vamos a copiar el Modelo "User.php" dentro del directorio "\App\Models".

Salimos y volvemos a entrara a tinker como se indica la siguiente secuela:

	$ php artisan tinker
	Psy Shell v0.9.12 (PHP 7.3.10 — cli) by Justin Hileman
	>>> $user = User::find(1);
	[!] Aliasing 'User' to 'App\User' for this Tinker session.
	PHP Deprecated:  The "Doctrine/Common/Inflector/Inflector::pluralize" method is deprecated and will be dropped in doctrine/inflector 2.0. Please update to the new Inflector API. in C:/AppServ/www/dev/CRUDLaravel5.5/vendor/doctrine/inflector/lib/Doctrine/Common/Inflector/Inflector.php on line 264
	PHP Deprecated:  The "Doctrine/Common/Inflector/Inflector::pluralize" method is deprecated and will be dropped in doctrine/inflector 2.0. Please update to the new Inflector API. in C:/AppServ/www/dev/CRUDLaravel5.5/vendor/doctrine/inflector/lib/Doctrine/Common/Inflector/Inflector.php on line 264
	PHP Deprecated:  The "Doctrine/Common/Inflector/Inflector::pluralize" method is deprecated and will be dropped in doctrine/inflector 2.0. Please update to the new Inflector API. in C:/AppServ/www/dev/CRUDLaravel5.5/vendor/doctrine/inflector/lib/Doctrine/Common/Inflector/Inflector.php on line 264
	=> App\User {#3514
	     id: 1,
	     name: "Klvst3r",
	     email: "klvst3r@email.com",
	     created_at: "2022-06-22 22:51:51",
	     updated_at: "2022-06-22 22:51:51",
	     profession_id: 1,
	   }
	>>> $user->isAdmin();
	=> true


Notemos que devuelove verdadero ya que tanto hemos colocado la ruta correcta, pero si creamos otro Usuario rapidamente que se va a almacenar en una variable llamada "$anotherUser" Vamos a colocarle el nombre "Another user", el email va a ser "another@user.com"    y como password es '123' y no vamos a agregar ninguna profesión:

	>>> $anotherUser = User::create(['name' => 'Another user', 'email' => 'another@user.com', 'password' => bcrypt(123)]);
	PHP Deprecated:  The "Doctrine/Common/Inflector/Inflector::pluralize" method is deprecated and will be dropped in doctrine/inflector 2.0. Please update to the new Inflector API. in C:/AppServ/www/dev/CRUDLaravel5.5/vendor/doctrine/inflector/lib/Doctrine/Common/Inflector/Inflector.php on line 264
	PHP Deprecated:  The "Doctrine/Common/Inflector/Inflector::pluralize" method is deprecated and will be dropped in doctrine/inflector 2.0. Please update to the new Inflector API. in C:/AppServ/www/dev/CRUDLaravel5.5/vendor/doctrine/inflector/lib/Doctrine/Common/Inflector/Inflector.php on line 264
	=> App\User {#4129
	     name: "Another user",
	     email: "another@user.com",
	     updated_at: "2022-07-01 19:00:32",
	     created_at: "2022-07-01 19:00:32",
	     id: 2,
	   }
	>>>

Si hacemos esto entonces tenemos ahora un nuevo usuario en la base de datos, podemos demostrarlo rapidamente:

	>>> User::all();


	>>> User::all();
	PHP Deprecated:  The "Doctrine/Common/Inflector/Inflector::pluralize" method is deprecated and will be dropped in doctrine/inflector 2.0. Please update to the new Inflector API. in C:/AppServ/www/dev/CRUDLaravel5.5/vendor/doctrine/inflector/lib/Doctrine/Common/Inflector/Inflector.php on line 264
	PHP Deprecated:  The "Doctrine/Common/Inflector/Inflector::pluralize" method is deprecated and will be dropped in doctrine/inflector 2.0. Please update to the new Inflector API. in C:/AppServ/www/dev/CRUDLaravel5.5/vendor/doctrine/inflector/lib/Doctrine/Common/Inflector/Inflector.php on line 264
	=> Illuminate\Database\Eloquent\Collection {#4127
	     all: [
	       App\User {#3913
	         id: 1,
	         name: "Klvst3r",
	         email: "klvst3r@email.com",
	         created_at: "2022-06-22 22:51:51",
	         updated_at: "2022-06-22 22:51:51",
	         profession_id: 1,
	       },
	       App\User {#3189
	         id: 2,
	         name: "Another user",
	         email: "another@user.com",
	         created_at: "2022-07-01 19:00:32",
	         updated_at: "2022-07-01 19:00:32",
	         profession_id: null,
	       },
	     ],
	   }
	>>>



Podemos ver que ahora tenemos dos usuarios el segundo usuario tiene el id:2, lo que quiere decir que pudo obtener este usuario utilizando:
	
	 >>> $user2 = User::find(2);



Entonces 2 como argumento, pero como se creo este usuario con eloquent y lo almacene en una variable llamada "$anotherUser" y se esta asignando la variable "$anotherUser" a resultado en la linea con el metodo «create()»:
	

	>>> $anotherUser = User::create(['name' => 'Another user', 'email' => 'another@user.com', 'password' => bcrypt(123)]);

quiere decir que ya tengo este usuario en la variable "$anotherUser", viasualizamos en consola de la siguiente manera:

	>>> $anotherUser
	=> App\User {#4129
	     name: "Another user",
	     email: "another@user.com",
	     updated_at: "2022-07-01 19:00:32",
	     created_at: "2022-07-01 19:00:32",
	     id: 2,
	   }
	>>>

Y podemos comenzar a trabajar con el directamente.

	>>> $anotherUser->isAdmin();
	=> false
	>>>


Notaramos que ahora al llamar al metodo "isadmin()" devuelve falso, nosotros tambien podemos declarar metodos estaticos dentro de nuesto modelo. 

Si regresamos al Modelo "User.php" podemos declarar un nuevo metodo estativo, de la siguiente manera llamada «findByEmail()».


Por supuesto el nombre es arbitrario al gial que el nombre del parametro, y se pueden crear los metodos que se quieran y con el nombre que se quiera, a menos que exista una limitación por ejemplo en el cao de que el siguiente metodo ya este registrado como parte del ORM de Eloquent y entonces aca podemos retornar el resultado de hacer una bsqueda donde el email del usuario sea iguial al email que reciba este metodo:



---User.php
...
	  public static function findByEmail($email)
    {
        return static::where(compact('email'))->first();
    }

...
---

Aca por ejemplo queremos retornar un solo resultado, por cierto aca estamos utilizando "static" en este caso es equivalente a escribirlo  utilizando "User" por eejmplo de la siguiente manera:


---User.php
...
	  public static function findByEmail($email)
    {
        return User::where(compact('email'))->first();
    }

...
---

Por que aca estoy dentro de la clase "User".

Con esto regresamos a la consola vamos a presionar CTRL + C para cerrar tinker y luego lo vamos a abrir nuevamente, u ahora entonces podemos buscar utilizando el metodo "findByEmail"

	> php artisan tinker

	 >>> $user = User::all();

	 >>> $user = User::find(1);

	 >>> User::findByEmail('klvst3r@email.com');
		=> App\User {#3874
		     id: 1,
		     name: "Klvst3r",
		     email: "klvst3r@email.com",
		     created_at: "2022-06-22 22:51:51",
		     updated_at: "2022-06-22 22:51:51",
		     profession_id: 1,
		   }
		>>>



Como podemos ver entonces este metodo retorno el usuario, ahora si pasamos un usuario que no este registrado, en el sistema, en este caso el metodo devuelve "null"


	 >>> User::findByEmail('another@email.com');
	=> null



Por que el metodo first() va a devolver null, asi que se debe tener cuidado con esto.

Tambien es importante destacar que los metodo staticos:

Ej.
	return static::where(compact('email'))->first();


O que se utilicen con una interfaz estatica como por ejemplo cuando utilizamos «User::create()» en este caso corresponden a la clase "User::create()" y la clase mas o menos va a corresponder a la tabla de la base de datos, mientras que los metodos no estaticos como por ejemplo:
	isAdmin()

O cuanto trabjemos con un objeto como por ejemplo

	$anotherUser

		o 
	User::all()

Por ejemplo cuando ejecutamos.

	>>>$anotherUser->isAdmin();

 Estos objetos se van a referir mas o menos a los tregistros o filas de la base de datos dentro de la tabla de usuarios. 

 Asi, que una manera en que podemos visualizar este modelo o que cada clase, corresponde a una tabla y cada objeto de dicho modelo de dicha clase, va a corresponder entonces a una fila o registro dentro de dicha tabla.








 


Ejercicios:
===========

Cuando pongo "Calendar::all()" en Tinker, me sale el siguiente error:

>>>
	PHP fatal error: Class 'Calendar' not found in Psy Shell code on line 1.

Yo tengo un controlador llamado Calendar, de hecho, he venido haciendo todo el curso con "Calendar" en vez de "Profession"ya que intento hacer un calendario en mi proyecto.

Entonces, para para la sección anterior en vez de crear un controlador Profession, lo hice "Calendar". Todo lo que trabajamos en la sección anterior me funcionó perfectamente, pero en este caso Tinker no me consigue eso.

Leí que puede ser por el namespace del controlador, pero no tiene mucho sentido puesto que "User" también tiene de namespace "App" y Tinker si me lo encuentra.

	Para mí esa característica de Tinker es un poco experimental y está allí por comodidad o como último recurso, si no te funciona simplemente coloca el nombre de espacio completo App\Calendar.

	También podrías intentar con composer dump-autoload.

	++

	Ya lo resolví, tuve que usar "composer dump-autoload" y luego intenté de nuevo y solventó.
	

- * - * -

Cual es la diferencia de usar «$user->find()» y «User::find()»; 	

	Es lo mismo, lo que pasa es que en $user ya deberia tener el modelo de User.
	$user = new User();
	$user->find(1);

- * - * -
Como es que desde los seeders puedes hacer «Profession::create(['title']=>'Desarrolador'])»; sin haber puesto 'title' en la variable $fillable del modelo ?
	
	Es porque en los seeders se invoca al metodo desde Model::unguarded ?

	Esa es la respuesta correcta ;) Model::unguarded() desabilita la protección de asignación masiva para todos los atributos del modelo, aun cuando el modelo tengas $fillable o $guarded definido. Así que usa el método con precaución

- * - * -

	Si se tuvo problemas de asignación en masa a la hora de crear un nuevo usuario desde Tinker, por ejemplo:

	$anotherUser=User::create(['user_profession_id'=>'1', 'user_firstname'=>'Pedrito', 'user_secondname'=>'Picapiedras', 'user_lastname'=>'Roca Dura', 'user_email'=>'picapiedras@gmail.com', 'user_password'=>bcrypt(123456), 'user_phone'=>'1234567890', 'user_gender'=>'Male', 'user_is_active'=>1, 'user_kind'=>'Administrator']);

	Recuerde que primero debe agregar esos campos al array protected $fillable al inicio de la declaración del Model. O sea, ponerlos como "rellenables" o que pueden ser asignados en masa desde Tinker:

	/**
	* The attributes that are mass assignable.
	*
	* @var array
	*/
	protected $fillable = [
	'user_profession_id',
	'user_firstname',
	'user_secondname',
	'user_lastname',
	'user_email',
	'user_password',
	'user_phone',
	'user_gender',
	'user_is_active',
	'user_kind',
	];


- * - * -

Surge este error, que cuando se ejecuta 'findByEmail()' me devuelve siempre y solamente el primer User. Por que puede ser?
	
	porque se esta usando ->first() con eso solo devuelve el primer valor que encuentra, y adicionalmente hay un solo usuario con el correo que le esta pasando como parametro.

- * - * -

